1. callAgreement(
    => CFA,
    abi encodeWithSelector(
        deleteFlow selector,
        token,
        sender,
        receiver,
        new bytes(0)
    )

)

0. bbreak time
1. createIndex
    -> interfaces check
    -> create, delete...
2. updateSubscription
    -> update subscriptions check
    -> subscript이 없으면 추가적으로 생성을 진ㅇㅏㅁ
    -> index data, subscription data의 차이로 시간 흐름을 계산
    -> subscript을 만들고 인덱스 vaule가 증가해야 할꺼 같음 (_updateIndex 를 통해서 wlsgod
3. updateIndex
4. claim
5. tokenDowngrade


chain of functioon calls
1. deleteAnyFlowBad
    - callAgreement , ctx
    -> read ctx 
2. Superfluid.callAgreement 
    - creates ctx, => puts stamp (check)
    - validate using superfluid.isCtxValid check
3. ConstantFlowAgreementV1.createFlow
    - verify autorized
4. Agreement


## Vuln Summary
- Host Contract => Superfluoid.sol (allow check)
    - ConstantFlowAgreement, InstantDistributionAgreement 단일 트랜잭션에서 구성된 시스템을 종종 Super Apps
- 서로 다른 컨트랙트 호출 간의 전체 거래를 통해 신뢰할 수 있고, 공유 된 상태를 갖기 위해서 ctx(호스트 컨트랙트에 의해 관리되는 직렬화) 도입
- ctx, 컨트랙트 기능이 알아야 할 모든 컨텍스트가 포함되어 있다. (msg.sender 초기화 작업)
- 불행한 취약점이 악용된 곳이다.

- 공격자는 호스트 컨트랙트에서 직렬화 프로세스와 컨트랙트 직렬화 해제 프로세스가 컨트랙트 수행을 할 수 있돌 위조 작업을 진행
- 이 메커니즘은 다른 컨트랙트를 대신해 인덱스를 작성하고 토큰을 그런 식으로 이동시키는 데 사용한다.


호출 체인 
- deleteAnyFlowBad
    - 합의의 규칙은 자리 표시 자 CTX를 사용해 나중에 컨트랙트 인수를 직접 읽으룻 있도록, 주입?

- SuperFluid callAgreement
    - ctx를 생성하고, 해시를 저장하여 상태 변수를 관리
- SuperFlowAggrementV1.createFlow
    - AggrementLibrary.authorizeTokenAccess를 사용해 호출 호슽 컨트랙트가 토큰 컨트랙트에서 상태 수정 호출을 수행 할 권한이 있는지 확인


superfluid = 0x3E14dC1b13c488a8d5D310918780c983bD5982E7
ida = 0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1
superusdc = 0xCAa7349CEA390F89641fe306D93591f87595dc1F
usdc = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174
victim = ?
victim = 0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188
fork_block_number = 24684668

eth_rpc_url = "https://rpc.ankr.com/eth"